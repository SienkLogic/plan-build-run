---
phase: "02-core-parsing-layer"
plan: "02-01"
type: "infrastructure"
wave: 1
depends_on: ["01-01"]
files_modified:
  - "package.json"
  - "vitest.config.js"
  - "src/repositories/planning.repository.js"
  - "tests/repositories/planning.repository.test.js"
autonomous: true
discovery: 0
must_haves:
  truths:
    - "readMarkdownFile(filePath) returns {frontmatter, html, rawContent} for a markdown file with YAML frontmatter"
    - "UTF-8 BOM is stripped before gray-matter parsing"
    - "gray-matter JavaScript engine is disabled (engines: { javascript: false })"
    - "readMarkdownFiles(filePaths) reads multiple files in parallel via Promise.all()"
    - "readMarkdownFilesSettled(filePaths) reads multiple files with partial failure tolerance via Promise.allSettled()"
    - "listPlanningFiles(projectDir) recursively lists all .md files under .planning/"
    - "Missing file throws an error with code ENOENT"
    - "Empty frontmatter returns data: {} (not an error)"
    - "All paths use path.join/path.resolve"
    - "Unit tests pass using memfs in-memory filesystem mocks"
  artifacts:
    - "src/repositories/planning.repository.js with readMarkdownFile, readMarkdownFiles, readMarkdownFilesSettled, listPlanningFiles"
    - "tests/repositories/planning.repository.test.js with comprehensive test coverage"
    - "vitest.config.js with test configuration"
    - "package.json with gray-matter, marked, memfs dependencies"
  key_links:
    - "planning.repository.js imports from node:fs/promises, gray-matter, marked"
    - "Test file mocks node:fs/promises with memfs"
    - "vitest.config.js configures test runner for the project"
provides:
  - "readMarkdownFile(filePath) function"
  - "readMarkdownFiles(filePaths) function"
  - "readMarkdownFilesSettled(filePaths) function"
  - "listPlanningFiles(projectDir) function"
  - "Vitest test infrastructure"
---

# Plan 02-01: Repository Layer Implementation and Tests

## Overview

Replace the placeholder `planning.repository.js` with a fully functional repository
that reads, parses, and lists markdown files with YAML frontmatter from `.planning/`
directories. Install gray-matter and marked as production dependencies, memfs as a
dev dependency. Create vitest configuration and comprehensive unit tests using memfs
for in-memory filesystem mocking.

After this plan, the repository layer is fully functional and tested. The service
layer (Plan 02-02) will build on these exports.

## Tasks

<task id="02-01-T1" type="auto">
  <name>Install parsing dependencies and create vitest configuration</name>
  <files>
    package.json
    vitest.config.js
  </files>
  <action>
    All file paths are relative to `D:\Repos\towline-test-project`.

    1. Install production dependencies for markdown/frontmatter parsing:
       ```
       npm install gray-matter marked
       ```

    2. Install dev dependency for in-memory filesystem testing:
       ```
       npm install -D memfs
       ```

    3. Create `vitest.config.js` at the project root:
       ```javascript
       import { defineConfig } from 'vitest/config';

       export default defineConfig({
         test: {
           globals: false,
           environment: 'node',
           include: ['tests/**/*.test.js'],
           testTimeout: 10000
         }
       });
       ```

       Key points:
       - `globals: false` requires explicit imports from 'vitest' (clearer, no magic globals)
       - `environment: 'node'` for filesystem testing (not jsdom)
       - Test files must live under `tests/` directory with `.test.js` suffix
       - 10s timeout is generous but prevents hangs

    4. Verify the dependencies are importable by running:
       ```
       node -e "import('gray-matter').then(() => console.log('gray-matter ok'))"
       node -e "import('marked').then(() => console.log('marked ok'))"
       ```
  </action>
  <verify>
    cd /d D:\Repos\towline-test-project && node -e "import('gray-matter').then(() => console.log('gray-matter ok'))" && node -e "import('marked').then(() => console.log('marked ok'))" && node -e "import('memfs').then(() => console.log('memfs ok'))" && node -e "import('vitest/config').then(() => console.log('vitest config ok'))" && node -e "import('fs').then(m => m.promises.stat('vitest.config.js').then(() => console.log('vitest.config.js exists')))"
  </verify>
  <done>gray-matter, marked, and memfs are installed; vitest.config.js exists and configures the test runner</done>
</task>

<task id="02-01-T2" type="auto">
  <name>Implement planning repository with parsing functions and unit tests</name>
  <files>
    src/repositories/planning.repository.js
    tests/repositories/planning.repository.test.js
  </files>
  <action>
    All file paths are relative to `D:\Repos\towline-test-project`.

    1. REPLACE the existing `src/repositories/planning.repository.js` entirely with
       the real implementation. The existing file is a placeholder that only exports
       `readProjectMetadata()` which throws "not implemented". Replace it completely:

       ```javascript
       import { readFile, readdir } from 'node:fs/promises';
       import { join } from 'node:path';
       import matter from 'gray-matter';
       import { marked } from 'marked';

       /**
        * Strip UTF-8 BOM (Byte Order Mark) if present.
        * Windows editors (Notepad, older VS Code) may prepend BOM to UTF-8 files.
        * gray-matter will fail to detect frontmatter delimiters if BOM is present.
        * @param {string} content - Raw file content
        * @returns {string} Content without BOM
        */
       function stripBOM(content) {
         return content.replace(/^\uFEFF/, '');
       }

       /**
        * Read and parse a single markdown file with YAML frontmatter.
        *
        * @param {string} filePath - Absolute path to the markdown file
        * @returns {Promise<{frontmatter: object, html: string, rawContent: string}>}
        * @throws {Error} ENOENT if file does not exist, parse error if YAML is malformed
        */
       export async function readMarkdownFile(filePath) {
         const fileContent = await readFile(filePath, 'utf-8');
         const cleanContent = stripBOM(fileContent);

         const { data, content } = matter(cleanContent, {
           engines: {
             javascript: false
           }
         });

         const html = marked.parse(content);

         return {
           frontmatter: data,
           html,
           rawContent: content
         };
       }

       /**
        * Read and parse multiple markdown files in parallel (fail-fast).
        * If any file fails, the entire operation rejects immediately.
        *
        * @param {string[]} filePaths - Array of absolute file paths
        * @returns {Promise<Array<{frontmatter: object, html: string, rawContent: string}>>}
        */
       export async function readMarkdownFiles(filePaths) {
         return Promise.all(
           filePaths.map(filePath => readMarkdownFile(filePath))
         );
       }

       /**
        * Read and parse multiple markdown files with partial failure tolerance.
        * All reads complete even if some fail. Returns settled results.
        *
        * @param {string[]} filePaths - Array of absolute file paths
        * @returns {Promise<Array<{status: 'fulfilled', value: object} | {status: 'rejected', reason: Error}>>}
        */
       export async function readMarkdownFilesSettled(filePaths) {
         return Promise.allSettled(
           filePaths.map(filePath => readMarkdownFile(filePath))
         );
       }

       /**
        * List all markdown files under the .planning/ directory recursively.
        * Uses native fs.readdir with recursive option (Node.js 18.17+).
        *
        * @param {string} projectDir - Absolute path to the project root
        * @returns {Promise<string[]>} Array of absolute file paths to .md files
        * @throws {Error} ENOENT if .planning/ directory does not exist
        */
       export async function listPlanningFiles(projectDir) {
         const planningDir = join(projectDir, '.planning');
         const entries = await readdir(planningDir, {
           recursive: true,
           withFileTypes: true
         });

         return entries
           .filter(entry => entry.isFile() && entry.name.endsWith('.md'))
           .map(entry => join(entry.parentPath || entry.path, entry.name));
       }
       ```

       Key decisions:
       - `stripBOM()` as a named internal function for clarity
       - `engines: { javascript: false }` prevents RCE via malicious frontmatter
       - `marked.parse()` called synchronously (no async option needed)
       - `readMarkdownFiles()` uses fail-fast `Promise.all()` for cases where all files must succeed
       - `readMarkdownFilesSettled()` uses `Promise.allSettled()` for partial failure tolerance
       - `listPlanningFiles()` uses native `readdir({ recursive: true })` -- no external glob dependency
       - `entry.parentPath || entry.path` handles both Node.js 20+ (parentPath) and Node.js 18 (path)
       - All path construction uses `join()` from `node:path`

    2. Create `tests/repositories/planning.repository.test.js`:

       ```javascript
       import { describe, it, expect, beforeEach, vi } from 'vitest';
       import { vol } from 'memfs';

       // Mock node:fs/promises with memfs BEFORE importing the module under test
       vi.mock('node:fs/promises', async () => {
         const memfs = await import('memfs');
         return memfs.fs.promises;
       });

       // Import AFTER mock is set up
       const {
         readMarkdownFile,
         readMarkdownFiles,
         readMarkdownFilesSettled,
         listPlanningFiles
       } = await import('../../src/repositories/planning.repository.js');

       describe('PlanningRepository', () => {
         beforeEach(() => {
           vol.reset();
         });

         describe('readMarkdownFile', () => {
           it('should parse frontmatter and render markdown to HTML', async () => {
             vol.fromJSON({
               '/project/doc.md': '---\ntitle: Test Doc\nstatus: draft\n---\n# Hello World\n\nSome content here.'
             });

             const result = await readMarkdownFile('/project/doc.md');

             expect(result.frontmatter).toEqual({ title: 'Test Doc', status: 'draft' });
             expect(result.html).toContain('<h1>');
             expect(result.html).toContain('Hello World');
             expect(result.html).toContain('<p>Some content here.</p>');
             expect(result.rawContent).toContain('# Hello World');
           });

           it('should strip UTF-8 BOM before parsing', async () => {
             vol.fromJSON({
               '/project/bom.md': '\uFEFF---\ntitle: BOM File\n---\n# BOM Content'
             });

             const result = await readMarkdownFile('/project/bom.md');

             expect(result.frontmatter.title).toBe('BOM File');
             expect(result.html).toContain('BOM Content');
           });

           it('should handle empty frontmatter without error', async () => {
             vol.fromJSON({
               '/project/empty-fm.md': '---\n---\n# No Frontmatter Data'
             });

             const result = await readMarkdownFile('/project/empty-fm.md');

             expect(result.frontmatter).toEqual({});
             expect(result.html).toContain('No Frontmatter Data');
           });

           it('should handle file with no frontmatter at all', async () => {
             vol.fromJSON({
               '/project/no-fm.md': '# Just Markdown\n\nNo frontmatter here.'
             });

             const result = await readMarkdownFile('/project/no-fm.md');

             expect(result.frontmatter).toEqual({});
             expect(result.html).toContain('Just Markdown');
             expect(result.html).toContain('No frontmatter here.');
           });

           it('should throw ENOENT for missing files', async () => {
             await expect(readMarkdownFile('/project/missing.md'))
               .rejects
               .toThrow();

             try {
               await readMarkdownFile('/project/missing.md');
             } catch (error) {
               expect(error.code).toBe('ENOENT');
             }
           });

           it('should throw on malformed YAML frontmatter', async () => {
             vol.fromJSON({
               '/project/bad.md': '---\ntitle: [invalid yaml\n  broken: {{\n---\n# Content'
             });

             await expect(readMarkdownFile('/project/bad.md'))
               .rejects
               .toThrow();
           });

           it('should handle complex frontmatter with nested objects and arrays', async () => {
             const content = [
               '---',
               'title: Complex',
               'tags:',
               '  - alpha',
               '  - beta',
               'meta:',
               '  author: test',
               '  version: 2',
               '---',
               '# Complex Doc'
             ].join('\n');

             vol.fromJSON({ '/project/complex.md': content });

             const result = await readMarkdownFile('/project/complex.md');

             expect(result.frontmatter.title).toBe('Complex');
             expect(result.frontmatter.tags).toEqual(['alpha', 'beta']);
             expect(result.frontmatter.meta).toEqual({ author: 'test', version: 2 });
           });

           it('should render GFM features (tables, task lists)', async () => {
             const content = '---\ntitle: GFM\n---\n| Col1 | Col2 |\n|------|------|\n| A    | B    |';

             vol.fromJSON({ '/project/gfm.md': content });

             const result = await readMarkdownFile('/project/gfm.md');

             expect(result.html).toContain('<table>');
             expect(result.html).toContain('<td>A</td>');
           });
         });

         describe('readMarkdownFiles', () => {
           it('should read multiple files in parallel', async () => {
             vol.fromJSON({
               '/project/a.md': '---\ntitle: A\n---\n# File A',
               '/project/b.md': '---\ntitle: B\n---\n# File B',
               '/project/c.md': '---\ntitle: C\n---\n# File C'
             });

             const results = await readMarkdownFiles([
               '/project/a.md',
               '/project/b.md',
               '/project/c.md'
             ]);

             expect(results).toHaveLength(3);
             expect(results[0].frontmatter.title).toBe('A');
             expect(results[1].frontmatter.title).toBe('B');
             expect(results[2].frontmatter.title).toBe('C');
           });

           it('should reject if any file is missing (fail-fast)', async () => {
             vol.fromJSON({
               '/project/a.md': '---\ntitle: A\n---\n# File A'
             });

             await expect(readMarkdownFiles([
               '/project/a.md',
               '/project/missing.md'
             ])).rejects.toThrow();
           });

           it('should handle empty array', async () => {
             const results = await readMarkdownFiles([]);
             expect(results).toEqual([]);
           });
         });

         describe('readMarkdownFilesSettled', () => {
           it('should return all results even when some fail', async () => {
             vol.fromJSON({
               '/project/a.md': '---\ntitle: A\n---\n# File A'
             });

             const results = await readMarkdownFilesSettled([
               '/project/a.md',
               '/project/missing.md'
             ]);

             expect(results).toHaveLength(2);
             expect(results[0].status).toBe('fulfilled');
             expect(results[0].value.frontmatter.title).toBe('A');
             expect(results[1].status).toBe('rejected');
             expect(results[1].reason.code).toBe('ENOENT');
           });

           it('should handle all files succeeding', async () => {
             vol.fromJSON({
               '/project/a.md': '---\ntitle: A\n---\n# A',
               '/project/b.md': '---\ntitle: B\n---\n# B'
             });

             const results = await readMarkdownFilesSettled([
               '/project/a.md',
               '/project/b.md'
             ]);

             expect(results.every(r => r.status === 'fulfilled')).toBe(true);
           });
         });

         describe('listPlanningFiles', () => {
           it('should list all .md files recursively under .planning/', async () => {
             vol.fromJSON({
               '/project/.planning/STATE.md': '---\nstatus: active\n---\n# State',
               '/project/.planning/ROADMAP.md': '---\nphases: 3\n---\n# Roadmap',
               '/project/.planning/phases/01/PLAN.md': '---\nphase: 1\n---\n# Plan',
               '/project/.planning/config.json': '{"depth": "standard"}',
               '/project/README.md': '# Not in .planning'
             });

             const files = await listPlanningFiles('/project');

             // Should include only .md files under .planning/
             expect(files.length).toBe(3);
             // Should NOT include config.json or root README.md
             const filenames = files.map(f => f.split(/[\\/]/).pop());
             expect(filenames).toContain('STATE.md');
             expect(filenames).toContain('ROADMAP.md');
             expect(filenames).toContain('PLAN.md');
             expect(filenames).not.toContain('config.json');
             expect(filenames).not.toContain('README.md');
           });

           it('should throw ENOENT if .planning/ directory does not exist', async () => {
             vol.fromJSON({
               '/project/README.md': '# No planning dir'
             });

             await expect(listPlanningFiles('/project'))
               .rejects
               .toThrow();
           });

           it('should return empty array for .planning/ with no .md files', async () => {
             vol.fromJSON({
               '/project/.planning/config.json': '{}'
             });

             const files = await listPlanningFiles('/project');
             expect(files).toEqual([]);
           });
         });
       });
       ```

       Key testing decisions:
       - `vi.mock('node:fs/promises')` replaces real fs with memfs for all tests
       - `vol.reset()` in `beforeEach()` prevents state leakage between tests
       - `await import()` after mock setup ensures the module under test uses the mock
       - Tests cover: basic parsing, BOM stripping, empty frontmatter, no frontmatter,
         missing files, malformed YAML, complex frontmatter, GFM rendering, parallel reads,
         partial failure tolerance, file listing, missing directory, empty directory
       - Error code assertions (`error.code === 'ENOENT'`) match the service layer's
         error handling pattern (planned for 02-02)
  </action>
  <verify>
    cd /d D:\Repos\towline-test-project && npx vitest run tests/repositories/planning.repository.test.js
  </verify>
  <done>readMarkdownFile returns parsed frontmatter and rendered HTML, BOM is stripped, JS engine is disabled, parallel read functions work, listPlanningFiles returns recursive .md listing, and all unit tests pass with memfs mocks</done>
</task>
