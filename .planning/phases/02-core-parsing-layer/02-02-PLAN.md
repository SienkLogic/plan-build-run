---
phase: "02-core-parsing-layer"
plan: "02-02"
type: "feature"
wave: 2
depends_on: ["02-01"]
files_modified:
  - "src/services/project.service.js"
  - "tests/services/project.service.test.js"
autonomous: true
discovery: 0
must_haves:
  truths:
    - "getHomepage(projectDir) reads .planning/README.md and returns {title, content} from parsed frontmatter and HTML"
    - "getHomepage returns fallback {title: 'Welcome', content: '<p>No project README found.</p>'} when README.md is missing (ENOENT)"
    - "getHomepage re-throws non-ENOENT errors (malformed YAML, permission denied)"
    - "getMarkdownFile(projectDir, relativePath) reads any file under .planning/ and returns parsed result"
    - "getMarkdownFile rejects paths that escape .planning/ (path traversal prevention)"
    - "Unit tests pass using memfs mocks"
  artifacts:
    - "src/services/project.service.js with getHomepage, getMarkdownFile"
    - "tests/services/project.service.test.js with comprehensive test coverage"
  key_links:
    - "project.service.js imports readMarkdownFile from planning.repository.js"
    - "project.service.js imports listPlanningFiles from planning.repository.js"
    - "getHomepage uses path.join(projectDir, '.planning', 'README.md') for cross-platform path"
    - "index.routes.js (from Phase 01) already calls getHomepage -- no route changes needed"
consumes:
  - "readMarkdownFile(filePath) from planning.repository.js (Plan 02-01)"
  - "readMarkdownFiles(filePaths) from planning.repository.js (Plan 02-01)"
  - "listPlanningFiles(projectDir) from planning.repository.js (Plan 02-01)"
provides:
  - "getHomepage(projectDir) function (enhanced from Phase 01 placeholder)"
  - "getMarkdownFile(projectDir, relativePath) function"
---

# Plan 02-02: Service Layer Enhancement and Tests

## Overview

Replace the placeholder `project.service.js` with a real service layer that calls
the repository functions from Plan 02-01. The service layer orchestrates business
logic: it knows which files to read, handles missing-file fallbacks gracefully, and
transforms repository data for the presentation layer. It also provides a general
`getMarkdownFile()` function for reading any file under `.planning/` with basic
path traversal protection.

After this plan, the full parsing pipeline works end-to-end: route calls service,
service calls repository, repository reads and parses files. The existing
`GET /` route in `index.routes.js` already calls `getHomepage()`, so no route
changes are needed.

## Tasks

<task id="02-02-T1" type="auto">
  <name>Implement service layer with getHomepage and getMarkdownFile</name>
  <files>
    src/services/project.service.js
  </files>
  <action>
    All file paths are relative to `D:\Repos\towline-test-project`.

    1. REPLACE the existing `src/services/project.service.js` entirely. The current
       file is a Phase 1 placeholder that returns hardcoded data. Replace it with
       real service logic that calls the repository:

       ```javascript
       import { join, resolve, relative } from 'node:path';
       import { readMarkdownFile, listPlanningFiles } from '../repositories/planning.repository.js';

       /**
        * Get homepage data for the dashboard.
        * Reads .planning/README.md if it exists, returns fallback data if not.
        *
        * @param {string} projectDir - Absolute path to the project root
        * @returns {Promise<{title: string, projectDir: string, content: string}>}
        */
       export async function getHomepage(projectDir) {
         try {
           const readmePath = join(projectDir, '.planning', 'README.md');
           const { frontmatter, html } = await readMarkdownFile(readmePath);

           return {
             title: frontmatter.title || 'Towline Dashboard',
             projectDir,
             content: html
           };
         } catch (error) {
           if (error.code === 'ENOENT') {
             return {
               title: 'Welcome',
               projectDir,
               content: '<p>No project README found.</p>'
             };
           }
           throw error;
         }
       }

       /**
        * Read a specific markdown file from within the .planning/ directory.
        * Validates that the resolved path stays within .planning/ to prevent
        * path traversal attacks.
        *
        * @param {string} projectDir - Absolute path to the project root
        * @param {string} relativePath - Path relative to .planning/ (e.g., 'phases/01/PLAN.md')
        * @returns {Promise<{frontmatter: object, html: string, rawContent: string}>}
        * @throws {Error} If path escapes .planning/ or file not found
        */
       export async function getMarkdownFile(projectDir, relativePath) {
         const planningDir = resolve(projectDir, '.planning');
         const filePath = resolve(planningDir, relativePath);

         // Path traversal protection: ensure resolved path is under .planning/
         const rel = relative(planningDir, filePath);
         if (rel.startsWith('..') || resolve(filePath) !== filePath && rel.startsWith('..')) {
           const err = new Error('Path traversal not allowed: path escapes .planning/ directory');
           err.code = 'PATH_TRAVERSAL';
           err.status = 403;
           throw err;
         }

         return readMarkdownFile(filePath);
       }
       ```

       Key decisions:
       - `getHomepage()` returns `projectDir` alongside title and content so the
         template can still display the project directory (matches Phase 01 template)
       - ENOENT catch returns a friendly fallback instead of crashing
       - Non-ENOENT errors (malformed YAML, permission denied) are re-thrown to
         propagate to the error handler middleware
       - `getMarkdownFile()` uses `path.relative()` to detect traversal: if the
         relative path from planningDir to filePath starts with `..`, it escapes
       - Custom error with `code: 'PATH_TRAVERSAL'` and `status: 403` for route-level handling
       - No `message` field in return -- renamed to `content` for HTML clarity
       - `listPlanningFiles` is imported but not yet consumed by a service function --
         it will be used by future phase services (Phase 04 dashboard, Phase 08 todos)
         and is available for direct import by those phases

    2. NOTE about existing route compatibility: The `index.routes.js` route calls
       `getHomepage(req.app.locals.projectDir)` and passes the result to
       `res.render('index', data)`. The Phase 01 `index.ejs` template expects
       `title`, `projectDir`, and `message`. The new service returns `title`,
       `projectDir`, and `content` (not `message`). This means the template variable
       name changed. However, the Phase 01 template uses `<%= message %>` which will
       render as empty string if undefined (EJS does not throw on undefined variables
       when using `<%= %>`). The `content` field contains HTML and should use
       `<%- content %>` (unescaped). This template change is NOT in scope for Phase 02 --
       it will be addressed in Phase 03 (UI Shell) when the templates are rebuilt.
       For Phase 02, the parsing pipeline works correctly; the template integration
       will be updated when templates are redesigned.
  </action>
  <verify>
    cd /d D:\Repos\towline-test-project && node -e "import('./src/services/project.service.js').then(m => { console.log('getHomepage:', typeof m.getHomepage); console.log('getMarkdownFile:', typeof m.getMarkdownFile); console.log('service imports ok'); })"
  </verify>
  <done>project.service.js exports getHomepage and getMarkdownFile, correctly imports from planning.repository.js, and handles ENOENT gracefully</done>
</task>

<task id="02-02-T2" type="auto">
  <name>Create service layer unit tests</name>
  <files>
    tests/services/project.service.test.js
  </files>
  <action>
    All file paths are relative to `D:\Repos\towline-test-project`.

    1. Create `tests/services/project.service.test.js`:

       ```javascript
       import { describe, it, expect, beforeEach, vi } from 'vitest';
       import { vol } from 'memfs';

       // Mock node:fs/promises with memfs BEFORE importing the module under test
       vi.mock('node:fs/promises', async () => {
         const memfs = await import('memfs');
         return memfs.fs.promises;
       });

       // Import AFTER mock is set up -- service imports repository which imports fs
       const { getHomepage, getMarkdownFile } = await import(
         '../../src/services/project.service.js'
       );

       describe('ProjectService', () => {
         beforeEach(() => {
           vol.reset();
         });

         describe('getHomepage', () => {
           it('should return parsed README.md content when file exists', async () => {
             vol.fromJSON({
               '/project/.planning/README.md': '---\ntitle: My Project\n---\n# Welcome\n\nProject overview here.'
             });

             const result = await getHomepage('/project');

             expect(result.title).toBe('My Project');
             expect(result.projectDir).toBe('/project');
             expect(result.content).toContain('<h1>');
             expect(result.content).toContain('Welcome');
             expect(result.content).toContain('Project overview here.');
           });

           it('should use default title when frontmatter has no title', async () => {
             vol.fromJSON({
               '/project/.planning/README.md': '---\nstatus: active\n---\n# Content'
             });

             const result = await getHomepage('/project');

             expect(result.title).toBe('Towline Dashboard');
           });

           it('should return fallback when README.md does not exist', async () => {
             vol.fromJSON({
               '/project/.planning/STATE.md': '---\nstatus: active\n---\n# State'
             });

             const result = await getHomepage('/project');

             expect(result.title).toBe('Welcome');
             expect(result.projectDir).toBe('/project');
             expect(result.content).toContain('No project README found');
           });

           it('should return fallback when .planning/ directory does not exist', async () => {
             vol.fromJSON({
               '/project/README.md': '# Root readme'
             });

             const result = await getHomepage('/project');

             expect(result.title).toBe('Welcome');
             expect(result.content).toContain('No project README found');
           });

           it('should re-throw non-ENOENT errors', async () => {
             vol.fromJSON({
               '/project/.planning/README.md': '---\ntitle: [broken yaml {{\n---\n# Bad'
             });

             await expect(getHomepage('/project'))
               .rejects
               .toThrow();
           });
         });

         describe('getMarkdownFile', () => {
           it('should read a file within .planning/ directory', async () => {
             vol.fromJSON({
               '/project/.planning/phases/01/PLAN.md': '---\nphase: 1\ntitle: Setup\n---\n# Phase 1 Plan'
             });

             const result = await getMarkdownFile('/project', 'phases/01/PLAN.md');

             expect(result.frontmatter.phase).toBe(1);
             expect(result.frontmatter.title).toBe('Setup');
             expect(result.html).toContain('Phase 1 Plan');
           });

           it('should read a file at the root of .planning/', async () => {
             vol.fromJSON({
               '/project/.planning/STATE.md': '---\ncurrent_phase: 2\n---\n# State'
             });

             const result = await getMarkdownFile('/project', 'STATE.md');

             expect(result.frontmatter.current_phase).toBe(2);
           });

           it('should throw ENOENT for missing files', async () => {
             vol.fromJSON({
               '/project/.planning/STATE.md': '# exists'
             });

             await expect(getMarkdownFile('/project', 'MISSING.md'))
               .rejects
               .toThrow();
           });

           it('should reject path traversal with ..', async () => {
             vol.fromJSON({
               '/project/.planning/STATE.md': '# state',
               '/project/secret.md': '# secret'
             });

             await expect(getMarkdownFile('/project', '../secret.md'))
               .rejects
               .toThrow('Path traversal not allowed');

             try {
               await getMarkdownFile('/project', '../secret.md');
             } catch (error) {
               expect(error.code).toBe('PATH_TRAVERSAL');
               expect(error.status).toBe(403);
             }
           });

           it('should reject deeply nested path traversal', async () => {
             vol.fromJSON({
               '/project/.planning/phases/01/PLAN.md': '# plan'
             });

             await expect(getMarkdownFile('/project', 'phases/../../secret.md'))
               .rejects
               .toThrow('Path traversal not allowed');
           });
         });
       });
       ```

       Key testing decisions:
       - Same memfs mock pattern as repository tests (consistent approach)
       - `vol.reset()` in `beforeEach()` prevents test pollution
       - `getHomepage` tests cover: normal case, missing title, missing README,
         missing .planning dir, malformed YAML re-throw
       - `getMarkdownFile` tests cover: normal read, root-level read, missing file,
         basic path traversal, deeply nested path traversal
       - Error code and status assertions for path traversal match the service
         implementation's custom error properties
  </action>
  <verify>
    cd /d D:\Repos\towline-test-project && npx vitest run tests/services/project.service.test.js
  </verify>
  <done>All service layer tests pass, confirming getHomepage reads .planning/README.md with ENOENT fallback, and getMarkdownFile enforces path traversal protection</done>
</task>

<task id="02-02-T3" type="auto">
  <name>Run full test suite to confirm all tests pass together</name>
  <files>
    tests/repositories/planning.repository.test.js
    tests/services/project.service.test.js
  </files>
  <action>
    This is a verification-only task. No files are modified.

    1. Run the complete test suite to ensure both test files pass together:
       ```
       cd D:\Repos\towline-test-project
       npx vitest run
       ```

    2. Verify that:
       - All repository tests pass (from Plan 02-01)
       - All service tests pass (from this plan)
       - No test interference between the two test files
       - Total test count matches expected (should be approximately 20 tests)

    3. Verify that the import chain works end-to-end:
       ```
       node -e "import('./src/services/project.service.js').then(m => m.getHomepage('.').then(r => console.log('Homepage title:', r.title)))"
       ```
       This should print "Welcome" (since there is no .planning/README.md in the
       test project root) or the title from a README.md if one exists.
  </action>
  <verify>
    cd /d D:\Repos\towline-test-project && npx vitest run
  </verify>
  <done>Full test suite passes with all repository and service tests green, confirming the complete Phase 02 parsing pipeline works: readMarkdownFile parses frontmatter and renders HTML, BOM is stripped, JS engine is disabled, parallel reads work, service handles ENOENT gracefully, and path traversal is blocked</done>
</task>
