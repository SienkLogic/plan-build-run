---
phase: "07-commit-history"
plan: "07-01"
type: "feature"
wave: 1
depends_on: ["05-02"]
files_modified:
  - "src/services/phase.service.js"
  - "tests/services/phase.service.test.js"
  - "src/views/phase-detail.ejs"
autonomous: true
discovery: 0
must_haves:
  truths:
    - "Phase detail page shows a Commit History section listing all commits from all plans"
    - "Commits are parsed from the Task Results table in SUMMARY.md body content"
    - "Each commit entry displays: abbreviated hash, task description, files count, and verification status"
    - "Phase with no commits (no SUMMARY files or no Task Results table) shows 'No commits yet' empty state"
    - "Phase with multiple plans groups commits by plan or shows them in plan order"
  artifacts:
    - "parseTaskResultsTable() function in src/services/phase.service.js"
    - "Commit History section in src/views/phase-detail.ejs"
    - "Unit tests covering table parsing, empty states, and edge cases in tests/services/phase.service.test.js"
  key_links:
    - "getPhaseDetail() returns a commits array on each plan object"
    - "phase-detail.ejs iterates plan.commits to render the commit history table"
    - "Route handler (pages.routes.js) unchanged -- data flows through existing getPhaseDetail call"
---

# Plan 07-01: Commit History for Phase Detail View

## Overview

Add a commit history section to the phase detail page. Commits are parsed from the "Task Results" markdown table found in each plan's SUMMARY.md body content. The data is already available via `readMarkdownFile().rawContent` -- this plan adds a parser for the table and a new template section to display results.

**Data flow**: `getPhaseDetail()` already reads each SUMMARY.md via `readMarkdownFile()`, which returns `rawContent` (the markdown body). The body contains a standardized "Task Results" table written by towline-executor. We parse this table with regex to extract commit hash, task description, files count, and verify status. No new route wiring or service calls needed -- the data rides on the existing `getPhaseDetail()` return value.

**No git dependency**: The Task Results table provides all required data (hash, description, files, status). Git enrichment (date, author, full message) is explicitly NOT included in this plan to keep the feature portable and dependency-free.

## Task 1: Add parseTaskResultsTable and integrate into getPhaseDetail

<task id="07-01-T1" type="auto" tdd="false">
  <name>Add parseTaskResultsTable function and enrich plan objects with commits</name>
  <files>
    src/services/phase.service.js
    tests/services/phase.service.test.js
  </files>
  <action>
    1. Open `src/services/phase.service.js`

    2. Add a new non-exported helper function `parseTaskResultsTable(rawContent)` ABOVE the `getPhaseDetail` function:

       ```javascript
       /**
        * Parse the "Task Results" markdown table from a SUMMARY.md body.
        * Returns an array of commit objects extracted from the table rows.
        *
        * Expected table format (produced by towline-executor):
        * | Task | Status | Commit | Files | Verify |
        * |------|--------|--------|-------|--------|
        * | 05-01-T1: Create phase.service.js | done | 2a52581 | 1 | passed |
        *
        * @param {string} rawContent - The markdown body content (after frontmatter)
        * @returns {Array<{task: string, status: string, hash: string, files: number, verify: string}>}
        */
       function parseTaskResultsTable(rawContent) {
         if (!rawContent) return [];

         // Find the Task Results section. The table may be followed by another section,
         // a blank line, or EOF. Use a non-greedy match to capture just the table block.
         const sectionRegex = /## Task Results\s*\n([\s\S]*?)(?=\n##\s|\n\n\n|$)/;
         const sectionMatch = rawContent.match(sectionRegex);
         if (!sectionMatch) return [];

         const tableBlock = sectionMatch[1].trim();
         const lines = tableBlock.split('\n');

         // Need at least header row + separator row + 1 data row = 3 lines
         if (lines.length < 3) return [];

         // Skip header row (index 0) and separator row (index 1)
         const dataRows = lines.slice(2);
         const commits = [];

         for (const row of dataRows) {
           // Split by pipe, trim, filter out empty strings from leading/trailing pipes
           const cells = row.split('|').map(c => c.trim()).filter(c => c);
           if (cells.length < 5) continue;

           const hash = cells[2];
           // Skip rows where commit is empty, a dash, or not a hex string
           if (!hash || hash === '-' || hash === '' || !/^[0-9a-f]{5,40}$/i.test(hash)) continue;

           commits.push({
             task: cells[0],
             status: cells[1],
             hash: hash,
             files: parseInt(cells[3], 10) || 0,
             verify: cells[4]
           });
         }

         return commits;
       }
       ```

    3. Modify the `getPhaseDetail` function. In the `plans` mapping section (around line 77-87), add a `commits` property to each plan object by parsing the rawContent:

       Change the fulfilled branch from:
       ```javascript
       if (result.status === 'fulfilled') {
         return { planId, planFile, summary: result.value.frontmatter, content: result.value.html };
       }
       ```
       To:
       ```javascript
       if (result.status === 'fulfilled') {
         return {
           planId,
           planFile,
           summary: result.value.frontmatter,
           content: result.value.html,
           commits: parseTaskResultsTable(result.value.rawContent)
         };
       }
       ```

       And change the ENOENT branch from:
       ```javascript
       return { planId, planFile, summary: null, content: null };
       ```
       To:
       ```javascript
       return { planId, planFile, summary: null, content: null, commits: [] };
       ```

    4. Export `parseTaskResultsTable` as a named export for direct unit testing. Change `function parseTaskResultsTable` to `export function parseTaskResultsTable`.

    5. Open `tests/services/phase.service.test.js`

    6. Update the import line to also import `parseTaskResultsTable`:
       ```javascript
       const { getPhaseDetail, parseTaskResultsTable } = await import('../../src/services/phase.service.js');
       ```

    7. Add a SUMMARY constant that includes a Task Results table. Place it after the existing `VALID_SUMMARY_FM_02` constant:

       ```javascript
       const SUMMARY_WITH_TASK_RESULTS = `---
       phase: "04-dashboard-landing-page"
       plan: "04-01"
       status: "complete"
       metrics:
         tasks_completed: 2
         tasks_total: 2
         commits: 2
         files_created: 2
         files_modified: 1
       ---

       # Plan Summary: 04-01

       ## What Was Built

       Dashboard service implementation.

       ## Task Results

       | Task | Status | Commit | Files | Verify |
       |------|--------|--------|-------|--------|
       | 04-01-T1: Create dashboard service | done | 9e1f738 | 1 | passed |
       | 04-01-T2: Write unit tests | done | 6df01e1 | 1 | passed |

       ## Key Implementation Details

       Some details here.
       `;

       const SUMMARY_NO_TASK_TABLE = `---
       phase: "04-dashboard-landing-page"
       plan: "04-02"
       status: "complete"
       metrics:
         tasks_completed: 1
         tasks_total: 1
       ---

       # Plan Summary: 04-02

       ## What Was Built

       Template implementation. No task results table in this summary.
       `;
       ```

    8. Add a new `describe('parseTaskResultsTable', ...)` block AFTER the existing `describe('PhaseService', ...)` block with these tests:

       ```javascript
       describe('parseTaskResultsTable', () => {
         it('should parse a valid Task Results table into commit objects', () => {
           const raw = `## Task Results

       | Task | Status | Commit | Files | Verify |
       |------|--------|--------|-------|--------|
       | 04-01-T1: Create service | done | 9e1f738 | 1 | passed |
       | 04-01-T2: Write tests | done | 6df01e1 | 2 | passed |

       ## Next Section`;

           const result = parseTaskResultsTable(raw);
           expect(result).toHaveLength(2);
           expect(result[0]).toEqual({
             task: '04-01-T1: Create service',
             status: 'done',
             hash: '9e1f738',
             files: 1,
             verify: 'passed'
           });
           expect(result[1].hash).toBe('6df01e1');
           expect(result[1].files).toBe(2);
         });

         it('should return empty array when rawContent is null or empty', () => {
           expect(parseTaskResultsTable(null)).toEqual([]);
           expect(parseTaskResultsTable('')).toEqual([]);
           expect(parseTaskResultsTable(undefined)).toEqual([]);
         });

         it('should return empty array when no Task Results section exists', () => {
           const raw = `## What Was Built

       Some description of what was done.

       ## Key Details

       Details here.`;

           expect(parseTaskResultsTable(raw)).toEqual([]);
         });

         it('should skip rows with invalid or missing commit hashes', () => {
           const raw = `## Task Results

       | Task | Status | Commit | Files | Verify |
       |------|--------|--------|-------|--------|
       | T1: Good commit | done | abc1234 | 1 | passed |
       | T2: No commit | done | - | 0 | skipped |
       | T3: Empty hash | done |  | 1 | passed |

       `;

           const result = parseTaskResultsTable(raw);
           expect(result).toHaveLength(1);
           expect(result[0].hash).toBe('abc1234');
         });

         it('should handle table at end of content (no trailing section)', () => {
           const raw = `## Task Results

       | Task | Status | Commit | Files | Verify |
       |------|--------|--------|-------|--------|
       | 01-01-T1: Scaffold project | done | f0b5a51 | 9 | passed |`;

           const result = parseTaskResultsTable(raw);
           expect(result).toHaveLength(1);
           expect(result[0].task).toBe('01-01-T1: Scaffold project');
           expect(result[0].files).toBe(9);
         });

         it('should handle malformed rows with fewer than 5 columns gracefully', () => {
           const raw = `## Task Results

       | Task | Status | Commit | Files | Verify |
       |------|--------|--------|-------|--------|
       | 01-01-T1: Good | done | aaa1111 | 2 | passed |
       | Broken row only two columns |
       | 01-01-T2: Also good | done | bbb2222 | 1 | passed |`;

           const result = parseTaskResultsTable(raw);
           expect(result).toHaveLength(2);
           expect(result[0].hash).toBe('aaa1111');
           expect(result[1].hash).toBe('bbb2222');
         });
       });
       ```

    9. Add a new test inside the existing `describe('PhaseService', ...)` block to verify that `getPhaseDetail` includes commits on plan objects:

       ```javascript
       it('should include parsed commits on plan objects with Task Results table', async () => {
         vol.fromJSON({
           '/project/.planning/phases/04-dashboard-landing-page/04-01-PLAN.md': '# Plan 04-01',
           '/project/.planning/phases/04-dashboard-landing-page/SUMMARY-04-01.md': SUMMARY_WITH_TASK_RESULTS
         });

         const result = await getPhaseDetail('/project', '04');

         expect(result.plans[0].commits).toHaveLength(2);
         expect(result.plans[0].commits[0].hash).toBe('9e1f738');
         expect(result.plans[0].commits[0].task).toContain('Create dashboard service');
         expect(result.plans[0].commits[1].hash).toBe('6df01e1');
       });

       it('should return empty commits array when plan has no SUMMARY', async () => {
         vol.fromJSON({
           '/project/.planning/phases/04-dashboard-landing-page/04-01-PLAN.md': '# Plan 04-01'
         });

         const result = await getPhaseDetail('/project', '04');

         expect(result.plans[0].commits).toEqual([]);
       });

       it('should return empty commits array when SUMMARY has no Task Results table', async () => {
         vol.fromJSON({
           '/project/.planning/phases/04-dashboard-landing-page/04-02-PLAN.md': '# Plan 04-02',
           '/project/.planning/phases/04-dashboard-landing-page/SUMMARY-04-02.md': SUMMARY_NO_TASK_TABLE
         });

         const result = await getPhaseDetail('/project', '04');

         expect(result.plans[0].commits).toEqual([]);
       });
       ```
  </action>
  <verify>
    cd D:/Repos/towline-test-project && npx vitest run tests/services/phase.service.test.js --reporter=verbose
  </verify>
  <done>
    parseTaskResultsTable correctly extracts commit data from SUMMARY.md body content. getPhaseDetail returns a commits array on every plan object (populated from Task Results table or empty array). All existing tests still pass and new tests validate parsing, empty states, and edge cases.
  </done>
</task>

## Task 2: Add Commit History section to phase-detail.ejs template

<task id="07-01-T2" type="auto" tdd="false">
  <name>Add Commit History section to phase-detail.ejs template</name>
  <files>
    src/views/phase-detail.ejs
  </files>
  <action>
    1. Open `src/views/phase-detail.ejs`

    2. After the closing `<% } %>` that ends the plans loop (the `plans.forEach` block ends around line 131, followed by `<% } %>` on line 133), and BEFORE the `<%- include('partials/layout-bottom') %>` line, add the Commit History section:

       ```ejs

       <!-- Commit History Section -->
       <%
         // Collect all commits across all plans, tagged with their planId
         var allCommits = [];
         plans.forEach(function(plan) {
           if (plan.commits && plan.commits.length > 0) {
             plan.commits.forEach(function(commit) {
               allCommits.push({ planId: plan.planId, commit: commit });
             });
           }
         });
       %>

       <h2>Commit History (<%= allCommits.length %>)</h2>

       <% if (allCommits.length === 0) { %>
       <article>
         <p><em>No commits yet for this phase.</em></p>
       </article>
       <% } else { %>
       <table>
         <thead>
           <tr>
             <th>Commit</th>
             <th>Task</th>
             <th>Plan</th>
             <th>Files</th>
             <th>Status</th>
           </tr>
         </thead>
         <tbody>
           <% allCommits.forEach(function(entry) { %>
           <tr>
             <td><code><%= entry.commit.hash %></code></td>
             <td><%= entry.commit.task %></td>
             <td><%= entry.planId %></td>
             <td><%= entry.commit.files %></td>
             <td>
               <span class="status-badge" data-status="<%= entry.commit.verify === 'passed' ? 'complete' : (entry.commit.verify === 'failed' ? 'blocked' : 'in-progress') %>">
                 <%= entry.commit.verify %>
               </span>
             </td>
           </tr>
           <% }); %>
         </tbody>
       </table>
       <% } %>
       ```

    3. Verify the insertion point is correct: the new section should appear AFTER the `<% } %>` that closes the `if (plans.length === 0) ... else ...` block (line 133 in the current file) and BEFORE `<%- include('partials/layout-bottom') %>` (line 135).

    4. Important XSS note: All commit data uses `<%= %>` (escaped output) -- NEVER use `<%- %>` for commit hashes, task descriptions, or verify status, since these come from user-controlled content in SUMMARY.md files.
  </action>
  <verify>
    cd D:/Repos/towline-test-project && node -e "const ejs = require('ejs'); const fs = require('fs'); const tpl = fs.readFileSync('src/views/phase-detail.ejs', 'utf8'); console.log(tpl.includes('Commit History') ? 'PASS: Commit History section found' : 'FAIL: Commit History section missing'); console.log(tpl.includes('allCommits') ? 'PASS: allCommits variable found' : 'FAIL: allCommits variable missing'); console.log(tpl.includes('No commits yet') ? 'PASS: Empty state found' : 'FAIL: Empty state missing'); console.log(!tpl.includes('<%- entry') ? 'PASS: No unescaped commit output' : 'FAIL: Unescaped commit output found (XSS risk)');"
    cd D:/Repos/towline-test-project && npx vitest run --reporter=verbose
  </verify>
  <done>
    Phase detail page displays a Commit History section with a table listing all commits across all plans. Each row shows the commit hash (monospaced), task description, plan ID, files count, and verification status with a color-coded badge. Phases with no commits display "No commits yet for this phase" empty state. All output uses escaped EJS tags to prevent XSS.
  </done>
</task>
