---
phase: "04-dashboard-landing-page"
plan: "04-01"
type: "feature"
wave: 1
depends_on: []
files_modified:
  - "src/services/dashboard.service.js"
  - "tests/services/dashboard.service.test.js"
autonomous: true
discovery: 0
must_haves:
  truths:
    - "parseStateFile extracts project name, current phase, last activity, and progress from STATE.md body text"
    - "parseRoadmapFile extracts phase list with checkbox status from ROADMAP.md body text"
    - "getDashboardData orchestrates both parsers and derives in-progress status for current phase"
    - "Missing STATE.md returns fallback data structure with sensible defaults"
    - "Missing ROADMAP.md returns fallback data structure with empty phases array"
    - "Divide-by-zero is handled when ROADMAP.md has no phase checkboxes"
  artifacts:
    - "src/services/dashboard.service.js"
    - "tests/services/dashboard.service.test.js"
  key_links:
    - "dashboard.service.js imports readFile from node:fs/promises (reads raw text, not readMarkdownFile)"
    - "parseStateFile uses regex on raw markdown body, not YAML frontmatter"
    - "parseRoadmapFile uses regex on raw markdown body, not YAML frontmatter"
    - "getDashboardData calls parseStateFile and parseRoadmapFile in parallel via Promise.all"
---

# Plan 04-01: Dashboard Data Parsing Service

## Summary

Create the dashboard service layer with parsing functions for STATE.md and ROADMAP.md.
These files use structured markdown body text (not YAML frontmatter), so parsing uses
regex on raw file content rather than the existing gray-matter-based repository layer.

A separate `dashboard.service.js` file is used (not added to `project.service.js`) because:
- The parsing logic is substantial (3 exported functions + 2 internal helpers)
- It has different concerns (regex body parsing vs frontmatter parsing)
- It avoids bloating the existing project.service.js
- The route layer can import from both services independently

## Tasks

<task id="04-01-T1" type="auto">
  <name>Create dashboard service with STATE.md and ROADMAP.md parsers</name>
  <files>
    src/services/dashboard.service.js
  </files>
  <action>
1. Create file `src/services/dashboard.service.js`

2. Import dependencies:
   ```javascript
   import { readFile } from 'node:fs/promises';
   import { join } from 'node:path';
   ```

3. Create internal helper `stripBOM(content)`:
   - Same as in planning.repository.js: `return content.replace(/^\uFEFF/, '');`
   - Duplicated intentionally -- this service reads raw text, not via the repository layer

4. Export async function `parseStateFile(projectDir)`:
   - Build path: `join(projectDir, '.planning', 'STATE.md')`
   - Read file with `readFile(path, 'utf-8')`, apply `stripBOM()`
   - Extract with regex patterns against the raw text:
     - Project name: `/\*\*Current focus:\*\*\s*(.+)/` -- extract group 1, trim
       - Fallback: if not found, try `/^# (.+)/m` to get the H1 heading
       - If neither found, use `'Unknown Project'`
     - Current phase: `/Phase:\s*(\d+)\s*of\s*(\d+)\s*\(([^)]+)\)/`
       - Group 1 = current phase number (parse as int)
       - Group 2 = total phases (parse as int)
       - Group 3 = phase name
     - Plan status: `/Plan:\s*(.+)/` -- extract group 1, trim
     - Last activity: `/Last activity:\s*([\d-]+)\s*--\s*(.+)/`
       - Group 1 = date string (YYYY-MM-DD)
       - Group 2 = description, trim
     - Progress: `/Progress:.*?(\d+)%/`
       - Group 1 = percentage (parse as int)
       - If not found, calculate from phase numbers: `Math.ceil((currentPhaseNum / totalPhases) * 100)`
   - Return object:
     ```javascript
     {
       projectName: string,       // from "Current focus" or H1 or fallback
       currentPhase: {
         id: number,              // current phase number
         total: number,           // total phases
         name: string,            // phase name from parentheses
         planStatus: string       // e.g. "2 of 2 complete"
       },
       lastActivity: {
         date: string,            // YYYY-MM-DD or ''
         description: string      // activity description or 'No activity recorded'
       },
       progress: number           // 0-100
     }
     ```
   - Wrap entire body in try-catch:
     - If `error.code === 'ENOENT'`, return fallback:
       ```javascript
       {
         projectName: 'Unknown Project',
         currentPhase: { id: 0, total: 0, name: 'Not Started', planStatus: 'N/A' },
         lastActivity: { date: '', description: 'No activity recorded' },
         progress: 0
       }
       ```
     - Otherwise re-throw the error

5. Export async function `parseRoadmapFile(projectDir)`:
   - Build path: `join(projectDir, '.planning', 'ROADMAP.md')`
   - Read file with `readFile(path, 'utf-8')`, apply `stripBOM()`
   - Parse phase checkboxes with regex: `/^- \[([ xX])\] Phase (\d+):\s*([^-]+?)\s*--\s*(.+)$/gm`
     - Use `[...content.matchAll(regex)]` to get all matches
     - For each match:
       - `match[1]` = checkbox state: `' '` means not-started, `'x'` or `'X'` means complete
       - `match[2]` = phase number (parse as int)
       - `match[3]` = phase name (trim)
       - `match[4]` = description (trim)
   - Build phases array:
     ```javascript
     const phases = matches.map(match => ({
       id: parseInt(match[2], 10),
       name: match[3].trim(),
       description: match[4].trim(),
       status: (match[1] === 'x' || match[1] === 'X') ? 'complete' : 'not-started'
     }));
     ```
   - Calculate progress:
     ```javascript
     const completed = phases.filter(p => p.status === 'complete').length;
     const total = phases.length;
     const progress = total > 0 ? Math.ceil((completed / total) * 100) : 0;
     ```
   - Return object:
     ```javascript
     {
       phases: phases,     // Array of phase objects
       progress: progress  // 0-100, derived from checkboxes
     }
     ```
   - Wrap entire body in try-catch:
     - If `error.code === 'ENOENT'`, return `{ phases: [], progress: 0 }`
     - Otherwise re-throw the error

6. Export async function `getDashboardData(projectDir)`:
   - Call both parsers in parallel:
     ```javascript
     const [stateData, roadmapData] = await Promise.all([
       parseStateFile(projectDir),
       parseRoadmapFile(projectDir)
     ]);
     ```
   - Derive "in-progress" status for the current phase:
     ```javascript
     const phases = roadmapData.phases.map(phase => ({
       ...phase,
       status: (phase.id === stateData.currentPhase.id && phase.status !== 'complete')
         ? 'in-progress'
         : phase.status
     }));
     ```
   - Choose progress source: prefer roadmapData.progress if phases exist, otherwise stateData.progress
     ```javascript
     const progress = roadmapData.phases.length > 0
       ? roadmapData.progress
       : stateData.progress;
     ```
   - Return combined object:
     ```javascript
     {
       projectName: stateData.projectName,
       currentPhase: stateData.currentPhase,
       lastActivity: stateData.lastActivity,
       progress: progress,
       phases: phases
     }
     ```
  </action>
  <verify>
    node -e "import('D:/Repos/towline-test-project/src/services/dashboard.service.js').then(m => console.log(Object.keys(m)))"
  </verify>
  <done>
    dashboard.service.js exports parseStateFile, parseRoadmapFile, and getDashboardData functions
  </done>
</task>

<task id="04-01-T2" type="auto">
  <name>Write unit tests for dashboard service parsing functions</name>
  <files>
    tests/services/dashboard.service.test.js
  </files>
  <action>
1. Create file `tests/services/dashboard.service.test.js`

2. Set up imports and mocks following the established pattern from project.service.test.js:
   ```javascript
   import { describe, it, expect, beforeEach, vi } from 'vitest';
   import { vol } from 'memfs';

   // Mock node:fs/promises with memfs BEFORE importing the module under test
   vi.mock('node:fs/promises', async () => {
     const memfs = await import('memfs');
     return memfs.fs.promises;
   });

   // Import AFTER mock is set up
   const { parseStateFile, parseRoadmapFile, getDashboardData } = await import(
     '../../src/services/dashboard.service.js'
   );
   ```

3. Add `beforeEach(() => { vol.reset(); });`

4. Create a realistic STATE.md test fixture string:
   ```javascript
   const VALID_STATE_MD = `# Project State

   ## Project Reference
   See: .planning/PROJECT.md (updated 2026-02-07)
   **Core value:** Visual insight into Towline project progress
   **Current focus:** Phase 3 - UI Shell

   ## Current Position
   Phase: 3 of 12 (UI Shell)
   Plan: 2 of 2 complete
   Status: Built and verified
   Last activity: 2026-02-08 -- Phase 3 built (2 plans, 5 tasks, 5 commits)
   Progress: [█████░░░░░░░░░░░░░░░] 25%
   `;
   ```

5. Create a realistic ROADMAP.md test fixture string:
   ```javascript
   const VALID_ROADMAP_MD = `# Roadmap: Towline Dashboard

   ## Phases

   - [x] Phase 01: Project Scaffolding -- Node.js project structure
   - [x] Phase 02: Core Parsing Layer -- Markdown/YAML repository
   - [x] Phase 03: UI Shell -- EJS layout system
   - [ ] Phase 04: Dashboard Landing Page -- Project overview page
   - [ ] Phase 05: Phase Detail View -- Phase detail page
   `;
   ```

6. Write `describe('parseStateFile')` tests:

   a. `it('should extract all fields from valid STATE.md')`:
      - vol.fromJSON with VALID_STATE_MD at `/project/.planning/STATE.md`
      - Call `parseStateFile('/project')`
      - Assert:
        - `result.projectName` contains 'Phase 3 - UI Shell' (from **Current focus:**)
        - `result.currentPhase.id` === 3
        - `result.currentPhase.total` === 12
        - `result.currentPhase.name` === 'UI Shell'
        - `result.currentPhase.planStatus` contains '2 of 2 complete'
        - `result.lastActivity.date` === '2026-02-08'
        - `result.lastActivity.description` contains 'Phase 3 built'
        - `result.progress` === 25

   b. `it('should return fallback when STATE.md does not exist')`:
      - vol.fromJSON with only `/project/.planning/ROADMAP.md` (no STATE.md)
      - Call `parseStateFile('/project')`
      - Assert:
        - `result.projectName` === 'Unknown Project'
        - `result.currentPhase.id` === 0
        - `result.currentPhase.name` === 'Not Started'
        - `result.lastActivity.description` === 'No activity recorded'
        - `result.progress` === 0

   c. `it('should return fallback when .planning/ directory does not exist')`:
      - vol.fromJSON with only `/project/README.md`
      - Call `parseStateFile('/project')`
      - Assert same fallback values as test b

   d. `it('should handle STATE.md with missing sections gracefully')`:
      - vol.fromJSON with STATE.md containing only `# Project State\n\nSome text but no sections`
      - Call `parseStateFile('/project')`
      - Assert:
        - `result.projectName` is 'Project State' (from H1) or 'Unknown Project'
        - `result.currentPhase.id` === 0
        - `result.progress` === 0

   e. `it('should handle UTF-8 BOM in STATE.md')`:
      - vol.fromJSON with `'\uFEFF' + VALID_STATE_MD` at STATE.md path
      - Call `parseStateFile('/project')`
      - Assert `result.currentPhase.id` === 3 (BOM does not break parsing)

7. Write `describe('parseRoadmapFile')` tests:

   a. `it('should extract phases with mixed checkbox states')`:
      - vol.fromJSON with VALID_ROADMAP_MD at `/project/.planning/ROADMAP.md`
      - Call `parseRoadmapFile('/project')`
      - Assert:
        - `result.phases.length` === 5
        - `result.phases[0].id` === 1
        - `result.phases[0].name` === 'Project Scaffolding'
        - `result.phases[0].status` === 'complete'
        - `result.phases[3].id` === 4
        - `result.phases[3].status` === 'not-started'
        - `result.progress` === 60 (3 of 5 = 60%, Math.ceil)

   b. `it('should handle all phases complete')`:
      - vol.fromJSON with ROADMAP containing only `[x]` checkboxes (2 phases)
      - Assert `result.progress` === 100

   c. `it('should handle all phases incomplete')`:
      - vol.fromJSON with ROADMAP containing only `[ ]` checkboxes (3 phases)
      - Assert `result.progress` === 0

   d. `it('should handle empty phases section')`:
      - vol.fromJSON with ROADMAP containing `# Roadmap\n\n## Phases\n\nNo phases yet.`
      - Assert `result.phases.length` === 0 and `result.progress` === 0

   e. `it('should return fallback when ROADMAP.md does not exist')`:
      - vol.fromJSON with only `/project/.planning/STATE.md`
      - Call `parseRoadmapFile('/project')`
      - Assert `result.phases` is empty array and `result.progress` === 0

   f. `it('should handle uppercase X in checkboxes')`:
      - vol.fromJSON with `- [X] Phase 01: Setup -- description`
      - Assert `result.phases[0].status` === 'complete'

   g. `it('should handle UTF-8 BOM in ROADMAP.md')`:
      - vol.fromJSON with BOM-prefixed ROADMAP
      - Assert phases are parsed correctly

8. Write `describe('getDashboardData')` tests:

   a. `it('should combine state and roadmap data')`:
      - vol.fromJSON with both VALID_STATE_MD and VALID_ROADMAP_MD
      - Call `getDashboardData('/project')`
      - Assert:
        - `result.projectName` contains 'Phase 3'
        - `result.phases.length` === 5
        - `result.progress` === 60 (from roadmap, since phases exist)

   b. `it('should mark current phase as in-progress')`:
      - vol.fromJSON with STATE.md showing Phase 3 current, ROADMAP with Phase 3 as `[ ]`
      - Call `getDashboardData('/project')`
      - Assert `result.phases[2].status` === 'in-progress' (Phase 03, index 2)
      - Assert other `[ ]` phases remain 'not-started'

   c. `it('should not override complete status with in-progress')`:
      - vol.fromJSON with STATE.md showing Phase 2 current, ROADMAP with Phase 2 as `[x]`
      - Call `getDashboardData('/project')`
      - Assert `result.phases[1].status` === 'complete' (not overridden)

   d. `it('should handle both files missing')`:
      - vol.fromJSON with only `/project/package.json`
      - Call `getDashboardData('/project')`
      - Assert:
        - `result.projectName` === 'Unknown Project'
        - `result.phases` is empty array
        - `result.progress` === 0

   e. `it('should handle STATE.md missing but ROADMAP.md present')`:
      - vol.fromJSON with only VALID_ROADMAP_MD
      - Call `getDashboardData('/project')`
      - Assert:
        - `result.projectName` === 'Unknown Project'
        - `result.phases.length` === 5
        - `result.progress` === 60
  </action>
  <verify>
    npx vitest run tests/services/dashboard.service.test.js --reporter=verbose
  </verify>
  <done>
    All dashboard service unit tests pass, covering valid parsing, ENOENT fallbacks, BOM handling, edge cases (empty phases, all complete, all incomplete, uppercase X), and getDashboardData orchestration with status derivation
  </done>
</task>
