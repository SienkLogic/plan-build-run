---
phase: "09-todo-write-operations"
plan: "09-01"
type: "feature"
wave: 1
depends_on: ["08-02"]
files_modified:
  - "src/services/todo.service.js"
  - "tests/services/todo.service.test.js"
autonomous: true
discovery: 0
must_haves:
  truths:
    - "createTodo writes a new markdown file with YAML frontmatter to .planning/todos/pending/"
    - "createTodo generates sequential IDs by scanning both pending/ and done/ directories"
    - "completeTodo moves a file from pending/ to done/ and updates status frontmatter to 'done'"
    - "All write operations are serialized through a sequential queue preventing concurrent corruption"
  artifacts:
    - "src/services/todo.service.js exports createTodo(projectDir, todoData)"
    - "src/services/todo.service.js exports completeTodo(projectDir, todoId)"
    - "tests/services/todo.service.test.js contains createTodo and completeTodo test suites"
  key_links:
    - "createTodo uses gray-matter stringify for frontmatter generation"
    - "completeTodo reads raw file and parses with gray-matter directly to preserve content for re-serialization"
    - "Both functions are wrapped by the same WriteQueue instance for serialization"
---

# Plan 09-01: Todo Write Service and Sequential Queue

## Overview

Add `createTodo` and `completeTodo` functions to the existing `todo.service.js` along with a `WriteQueue` class that serializes all write operations. Unit tests validate ID generation, file creation, file moving, frontmatter updates, and queue serialization behavior.

---

<task id="09-01-T1" type="auto">
  <name>Add WriteQueue, createTodo, and completeTodo to todo.service.js</name>
  <files>
    src/services/todo.service.js
  </files>
  <action>
1. Open `src/services/todo.service.js`
2. Add these imports at the top alongside existing imports:
   ```javascript
   import { readFile, writeFile, rename, mkdir, readdir as readdirFs } from 'node:fs/promises';
   import { join } from 'node:path';
   import matter from 'gray-matter';
   ```
   Note: `readdir` is already imported from `node:fs/promises` on line 1. The existing import uses `readdir` so import `readdir` only once. Rename the new one or reuse the existing one. Since the existing `readdir` import is already at the top, just add `readFile`, `writeFile`, `rename`, `mkdir` to the existing destructure. Remove `readdir` from the new import if already present.

   The final imports block should be:
   ```javascript
   import { readdir, readFile, writeFile, rename, mkdir } from 'node:fs/promises';
   import { join } from 'node:path';
   import matter from 'gray-matter';
   import { readMarkdownFile } from '../repositories/planning.repository.js';
   ```

3. Add the WriteQueue class after the `PRIORITY_ORDER` constant (before `sortTodosByPriority`):
   ```javascript
   /**
    * Sequential write queue to prevent concurrent file operations.
    * All write operations (create, complete) are serialized through this queue
    * to avoid race conditions in ID generation and file moves.
    */
   class WriteQueue {
     constructor() {
       this.tail = Promise.resolve();
     }

     enqueue(fn) {
       const task = this.tail.then(fn, fn);
       this.tail = task.catch(() => {}); // prevent unhandled rejection on queue chain
       return task;
     }
   }

   const writeQueue = new WriteQueue();
   ```

4. Add the `titleToSlug` helper function after the WriteQueue:
   ```javascript
   /**
    * Convert a title string to a filesystem-safe slug.
    * Lowercases, replaces non-alphanumeric chars with hyphens,
    * removes leading/trailing hyphens, and truncates to 50 chars.
    * @param {string} title - Raw title string
    * @returns {string} Kebab-case slug
    */
   function titleToSlug(title) {
     return title
       .toLowerCase()
       .replace(/[^a-z0-9]+/g, '-')
       .replace(/^-|-$/g, '')
       .slice(0, 50);
   }
   ```

5. Add the `getNextTodoId` helper function:
   ```javascript
   /**
    * Scan both pending/ and done/ directories to find the highest existing
    * todo ID, then return the next sequential ID as a zero-padded 3-digit string.
    * @param {string} projectDir - Absolute path to the project root
    * @returns {Promise<string>} Next ID, e.g. "007"
    */
   async function getNextTodoId(projectDir) {
     const pendingDir = join(projectDir, '.planning', 'todos', 'pending');
     const doneDir = join(projectDir, '.planning', 'todos', 'done');

     let highestId = 0;

     for (const dir of [pendingDir, doneDir]) {
       try {
         const files = await readdir(dir);
         for (const filename of files) {
           const match = filename.match(/^(\d{3})-/);
           if (match) {
             const id = parseInt(match[1], 10);
             if (id > highestId) highestId = id;
           }
         }
       } catch (err) {
         if (err.code !== 'ENOENT') throw err;
       }
     }

     return String(highestId + 1).padStart(3, '0');
   }
   ```

6. Add the `createTodo` function (exported):
   ```javascript
   /**
    * Create a new todo markdown file in .planning/todos/pending/.
    * Generates a sequential ID, writes YAML frontmatter + markdown body.
    * Enqueued through the write queue for concurrency safety.
    *
    * @param {string} projectDir - Absolute path to the project root
    * @param {{title: string, priority: string, phase?: string, description: string}} todoData
    * @returns {Promise<string>} The generated todo ID (e.g. "007")
    * @throws {Error} If title, priority, or description are missing
    */
   export async function createTodo(projectDir, todoData) {
     const { title, priority, description } = todoData;
     const phase = todoData.phase || '';

     if (!title || !priority || !description) {
       const err = new Error('Missing required fields: title, priority, and description are required');
       err.status = 400;
       throw err;
     }

     return writeQueue.enqueue(async () => {
       const todoId = await getNextTodoId(projectDir);
       const slug = titleToSlug(title);
       const filename = `${todoId}-${slug}.md`;
       const pendingDir = join(projectDir, '.planning', 'todos', 'pending');

       await mkdir(pendingDir, { recursive: true });

       const frontmatter = {
         id: todoId,
         title,
         priority,
         phase,
         status: 'pending',
         created: new Date().toISOString().split('T')[0]
       };

       const fileContent = matter.stringify(description, frontmatter);
       const filePath = join(pendingDir, filename);
       await writeFile(filePath, fileContent, 'utf-8');

       return todoId;
     });
   }
   ```

7. Add the `completeTodo` function (exported):
   ```javascript
   /**
    * Mark a todo as done by updating its status frontmatter and moving
    * the file from pending/ to done/.
    * Enqueued through the write queue for concurrency safety.
    *
    * @param {string} projectDir - Absolute path to the project root
    * @param {string} todoId - Three-digit todo ID (e.g. "001")
    * @returns {Promise<void>}
    * @throws {Error} With status 404 if todo is not found in pending/
    */
   export async function completeTodo(projectDir, todoId) {
     return writeQueue.enqueue(async () => {
       const pendingDir = join(projectDir, '.planning', 'todos', 'pending');
       const doneDir = join(projectDir, '.planning', 'todos', 'done');

       // Find the matching file in pending/
       let entries;
       try {
         entries = await readdir(pendingDir);
       } catch (err) {
         if (err.code === 'ENOENT') {
           const notFound = new Error(`Todo ${todoId} not found`);
           notFound.status = 404;
           throw notFound;
         }
         throw err;
       }

       const matchingFile = entries.find(name =>
         name.startsWith(`${todoId}-`) && name.endsWith('.md')
       );

       if (!matchingFile) {
         const notFound = new Error(`Todo ${todoId} not found`);
         notFound.status = 404;
         throw notFound;
       }

       // Read, update status, write back
       const pendingPath = join(pendingDir, matchingFile);
       const raw = await readFile(pendingPath, 'utf-8');
       const parsed = matter(raw, { engines: { javascript: false } });

       parsed.data.status = 'done';
       const updatedContent = matter.stringify(parsed.content, parsed.data);
       await writeFile(pendingPath, updatedContent, 'utf-8');

       // Move from pending/ to done/
       await mkdir(doneDir, { recursive: true });
       const donePath = join(doneDir, matchingFile);
       await rename(pendingPath, donePath);
     });
   }
   ```
  </action>
  <verify>
    npx --prefix D:/Repos/towline-test-project vitest run --reporter=verbose tests/services/todo.service.test.js 2>&1 | head -40
  </verify>
  <done>
    todo.service.js exports createTodo and completeTodo functions. Existing tests still pass (no regressions from adding new code).
  </done>
</task>

<task id="09-01-T2" type="auto">
  <name>Add unit tests for createTodo, completeTodo, and WriteQueue</name>
  <files>
    tests/services/todo.service.test.js
  </files>
  <action>
1. Open `tests/services/todo.service.test.js`
2. Update the dynamic import on line 11-13 to also import `createTodo` and `completeTodo`:
   ```javascript
   const { listPendingTodos, getTodoDetail, createTodo, completeTodo } = await import(
     '../../src/services/todo.service.js'
   );
   ```

3. Add the following test suites at the end of the file (after the `getTodoDetail` describe block, before the final line):

   ```javascript
   describe('createTodo', () => {
     it('should create a file in pending directory with correct frontmatter', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       const id = await createTodo('/project', {
         title: 'New task',
         priority: 'P1',
         phase: '09-todo-write-operations',
         description: 'Task description here'
       });

       expect(id).toBe('001');

       // Verify file was written
       const filePath = `/project/.planning/todos/pending/${id}-new-task.md`;
       const content = vol.readFileSync(filePath, 'utf-8');
       expect(content).toContain('title: New task');
       expect(content).toContain('priority: P1');
       expect(content).toContain('phase: 09-todo-write-operations');
       expect(content).toContain('status: pending');
       expect(content).toContain('Task description here');
     });

     it('should generate sequential IDs across multiple creates', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       const id1 = await createTodo('/project', {
         title: 'First',
         priority: 'P1',
         description: 'First task'
       });
       const id2 = await createTodo('/project', {
         title: 'Second',
         priority: 'P2',
         description: 'Second task'
       });

       expect(id1).toBe('001');
       expect(id2).toBe('002');
     });

     it('should account for existing files when generating IDs', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/005-existing.md': TODO_P1,
       });

       const id = await createTodo('/project', {
         title: 'After existing',
         priority: 'P2',
         description: 'Should get ID 006'
       });

       expect(id).toBe('006');
     });

     it('should account for files in done/ directory when generating IDs', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/001-pending.md': TODO_P1,
         '/project/.planning/todos/done/003-done.md': TODO_P0,
       });

       const id = await createTodo('/project', {
         title: 'After done',
         priority: 'P2',
         description: 'Should get ID 004'
       });

       expect(id).toBe('004');
     });

     it('should create pending directory if it does not exist', async () => {
       vol.fromJSON({
         '/project/package.json': '{}',
       });

       const id = await createTodo('/project', {
         title: 'No dir yet',
         priority: 'P1',
         description: 'Directory should be created'
       });

       expect(id).toBe('001');
       const files = vol.readdirSync('/project/.planning/todos/pending');
       expect(files.length).toBe(1);
     });

     it('should generate filesystem-safe slugs from titles', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       const id = await createTodo('/project', {
         title: 'Fix: Bug #42 (urgent!!)',
         priority: 'P0',
         description: 'Special chars in title'
       });

       const files = vol.readdirSync('/project/.planning/todos/pending');
       const created = files.find(f => f.startsWith(`${id}-`));
       expect(created).toBe(`${id}-fix-bug-42-urgent.md`);
     });

     it('should truncate long slugs to 50 characters', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       const longTitle = 'This is a very long title that should be truncated to fifty characters maximum';
       const id = await createTodo('/project', {
         title: longTitle,
         priority: 'P1',
         description: 'Long title test'
       });

       const files = vol.readdirSync('/project/.planning/todos/pending');
       const created = files.find(f => f.startsWith(`${id}-`));
       // Slug part (between ID- and .md) should be at most 50 chars
       const slugPart = created.replace(/^\d{3}-/, '').replace(/\.md$/, '');
       expect(slugPart.length).toBeLessThanOrEqual(50);
     });

     it('should throw 400 error when title is missing', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       try {
         await createTodo('/project', {
           priority: 'P1',
           description: 'No title'
         });
         expect.fail('Expected an error to be thrown');
       } catch (err) {
         expect(err.status).toBe(400);
       }
     });

     it('should throw 400 error when priority is missing', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       try {
         await createTodo('/project', {
           title: 'Has title',
           description: 'No priority'
         });
         expect.fail('Expected an error to be thrown');
       } catch (err) {
         expect(err.status).toBe(400);
       }
     });

     it('should throw 400 error when description is missing', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       try {
         await createTodo('/project', {
           title: 'Has title',
           priority: 'P1'
         });
         expect.fail('Expected an error to be thrown');
       } catch (err) {
         expect(err.status).toBe(400);
       }
     });

     it('should default phase to empty string when not provided', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       const id = await createTodo('/project', {
         title: 'No phase',
         priority: 'P1',
         description: 'Phase should be empty'
       });

       const filePath = `/project/.planning/todos/pending/${id}-no-phase.md`;
       const content = vol.readFileSync(filePath, 'utf-8');
       expect(content).toContain("phase: ''");
     });

     it('should serialize concurrent creates to prevent ID collisions', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/.gitkeep': '',
       });

       const [id1, id2, id3] = await Promise.all([
         createTodo('/project', { title: 'First', priority: 'P1', description: 'A' }),
         createTodo('/project', { title: 'Second', priority: 'P1', description: 'B' }),
         createTodo('/project', { title: 'Third', priority: 'P1', description: 'C' }),
       ]);

       // All IDs should be unique
       const ids = new Set([id1, id2, id3]);
       expect(ids.size).toBe(3);

       // IDs should be sequential
       const sorted = [id1, id2, id3].sort();
       expect(sorted).toEqual(['001', '002', '003']);
     });
   });

   describe('completeTodo', () => {
     it('should move file from pending to done directory', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/001-test-todo.md': TODO_P1,
       });

       await completeTodo('/project', '001');

       // Pending file should be gone
       const pendingFiles = vol.readdirSync('/project/.planning/todos/pending');
       expect(pendingFiles.find(f => f.startsWith('001-'))).toBeUndefined();

       // Done file should exist
       const doneFiles = vol.readdirSync('/project/.planning/todos/done');
       expect(doneFiles.find(f => f.startsWith('001-'))).toBe('001-test-todo.md');
     });

     it('should update status to done in frontmatter', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/001-test-todo.md': TODO_P1,
       });

       await completeTodo('/project', '001');

       const content = vol.readFileSync('/project/.planning/todos/done/001-test-todo.md', 'utf-8');
       expect(content).toContain('status: done');
       expect(content).not.toContain('status: pending');
     });

     it('should preserve other frontmatter fields when updating status', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/001-test-todo.md': TODO_P1,
       });

       await completeTodo('/project', '001');

       const content = vol.readFileSync('/project/.planning/todos/done/001-test-todo.md', 'utf-8');
       expect(content).toContain('title: Add audit logging to hook scripts');
       expect(content).toContain('priority: P1');
     });

     it('should create done directory if it does not exist', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/001-test-todo.md': TODO_P1,
       });

       await completeTodo('/project', '001');

       // No error thrown, and done dir exists with the file
       const doneFiles = vol.readdirSync('/project/.planning/todos/done');
       expect(doneFiles.length).toBe(1);
     });

     it('should throw 404 when todo ID does not exist in pending', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/001-test-todo.md': TODO_P1,
       });

       try {
         await completeTodo('/project', '999');
         expect.fail('Expected an error to be thrown');
       } catch (err) {
         expect(err.status).toBe(404);
         expect(err.message).toContain('999');
       }
     });

     it('should throw 404 when pending directory does not exist', async () => {
       vol.fromJSON({
         '/project/package.json': '{}',
       });

       try {
         await completeTodo('/project', '001');
         expect.fail('Expected an error to be thrown');
       } catch (err) {
         expect(err.status).toBe(404);
       }
     });

     it('should preserve markdown body content after completion', async () => {
       vol.fromJSON({
         '/project/.planning/todos/pending/001-test-todo.md': TODO_P1,
       });

       await completeTodo('/project', '001');

       const content = vol.readFileSync('/project/.planning/todos/done/001-test-todo.md', 'utf-8');
       expect(content).toContain('Hook scripts currently have no audit trail.');
     });
   });
   ```
  </action>
  <verify>
    npx --prefix D:/Repos/towline-test-project vitest run --reporter=verbose tests/services/todo.service.test.js
  </verify>
  <done>
    All unit tests pass: createTodo writes correctly formatted files with sequential IDs, completeTodo moves files and updates status, concurrent creates produce unique IDs, validation rejects missing fields, and existing listPendingTodos/getTodoDetail tests still pass.
  </done>
</task>
