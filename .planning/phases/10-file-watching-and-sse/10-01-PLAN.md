---
phase: "10-file-watching-and-sse"
plan: "10-01"
type: "feature"
wave: 1
depends_on: ["04-02", "08-02"]
files_modified:
  - "package.json"
  - "src/services/watcher.service.js"
  - "src/services/sse.service.js"
  - "src/routes/events.routes.js"
  - "src/app.js"
  - "src/server.js"
  - "tests/services/sse.service.test.js"
  - "tests/services/watcher.service.test.js"
autonomous: true
discovery: 0
must_haves:
  truths:
    - "Chokidar watches join(projectDir, '.planning') with **/*.md glob and awaitWriteFinish debouncing"
    - "SSE service manages a Set of client response objects and can broadcast events to all of them"
    - "GET /api/events/stream returns an SSE connection with Content-Type: text/event-stream headers"
    - "File changes emit SSE file-change events with path, type, and timestamp payload"
    - "Heartbeat comments are sent every 30 seconds to keep SSE connections alive"
    - "Client disconnect triggers cleanup (remove from Set, clear heartbeat interval)"
    - "Watcher closes gracefully on server shutdown before server.close()"
  artifacts:
    - "src/services/watcher.service.js exports createWatcher(watchPath, onChange)"
    - "src/services/sse.service.js exports addClient, removeClient, broadcast, getClientCount, clearClients"
    - "src/routes/events.routes.js exports Express router with GET /stream"
    - "src/app.js updated with events route at /api/events"
    - "src/server.js updated to create watcher and close it on shutdown"
    - "tests/services/sse.service.test.js with 7 unit tests"
    - "tests/services/watcher.service.test.js with 5 unit tests"
  key_links:
    - "server.js imports createWatcher from watcher.service.js"
    - "server.js wires watcher onChange to sse.service.broadcast"
    - "server.js closes watcher in shutdown handler before server.close()"
    - "app.js mounts eventsRouter at /api/events"
    - "events.routes.js imports addClient, removeClient from sse.service.js"
---

# Plan 10-01: File Watcher Service, SSE Service, SSE Route, and Server Lifecycle

## Overview

Install chokidar, create the file watcher service (wraps chokidar with normalized events),
the SSE service (client connection management and broadcasting), and the SSE route
(GET /api/events/stream). Update app.js to mount the events route and server.js to
create the watcher, wire it to SSE broadcasts, and close it gracefully on shutdown.

This plan is entirely backend. The browser-side EventSource client is Plan 10-02.

## Tasks

<task id="10-01-T1" type="auto">
  <name>Install chokidar and create watcher service and SSE service with unit tests</name>
  <files>
    package.json
    src/services/watcher.service.js
    src/services/sse.service.js
    tests/services/sse.service.test.js
    tests/services/watcher.service.test.js
  </files>
  <action>
1. Install chokidar in the test project:
   ```bash
   cd D:\Repos\towline-test-project && npm install chokidar@^5.0.0
   ```
   Verify that package.json now includes `"chokidar": "^5.0.0"` in dependencies.

2. Create `src/services/sse.service.js` with the following content:
   ```javascript
   /**
    * SSE (Server-Sent Events) service.
    * Manages a Set of active client response objects and provides
    * broadcast functionality to send events to all connected browsers.
    */

   /** @type {Set<import('http').ServerResponse>} */
   const clients = new Set();

   /**
    * Register a client response object for SSE broadcasting.
    * @param {import('http').ServerResponse} res
    */
   export function addClient(res) {
     clients.add(res);
   }

   /**
    * Remove a client response object (called on disconnect).
    * @param {import('http').ServerResponse} res
    */
   export function removeClient(res) {
     clients.delete(res);
   }

   /**
    * Broadcast an SSE event to all connected clients.
    * Clients that throw on write are automatically removed.
    * @param {string} eventType - SSE event name (e.g. 'file-change')
    * @param {object} data - Payload to JSON-serialize in the data field
    */
   export function broadcast(eventType, data) {
     const id = Date.now();
     const message = `event: ${eventType}\ndata: ${JSON.stringify(data)}\nid: ${id}\n\n`;

     for (const client of clients) {
       try {
         client.write(message);
       } catch {
         clients.delete(client);
       }
     }
   }

   /**
    * Return the number of currently connected clients.
    * @returns {number}
    */
   export function getClientCount() {
     return clients.size;
   }

   /**
    * Remove all clients. Used in tests to reset state between test cases.
    */
   export function clearClients() {
     clients.clear();
   }
   ```

3. Create `src/services/watcher.service.js` with the following content:
   ```javascript
   import chokidar from 'chokidar';
   import { join, relative } from 'node:path';

   /**
    * Create a chokidar file watcher for the .planning/ directory.
    *
    * Watches **\/*.md files with awaitWriteFinish to debounce editor saves.
    * Calls onChange with a normalized event object on add, change, and unlink.
    *
    * @param {string} watchPath - Absolute path to the project directory
    * @param {(event: {path: string, type: string, timestamp: number}) => void} onChange
    * @returns {import('chokidar').FSWatcher}
    */
   export function createWatcher(watchPath, onChange) {
     const planningDir = join(watchPath, '.planning');

     const watcher = chokidar.watch(join(planningDir, '**/*.md'), {
       ignored: [
         '**/node_modules/**',
         '**/.git/**'
       ],
       persistent: true,
       ignoreInitial: true,
       awaitWriteFinish: {
         stabilityThreshold: 2000,
         pollInterval: 100
       }
     });

     const handleEvent = (type) => (filePath) => {
       const relativePath = relative(watchPath, filePath);
       onChange({
         path: relativePath,
         type,
         timestamp: Date.now()
       });
     };

     watcher.on('add', handleEvent('add'));
     watcher.on('change', handleEvent('change'));
     watcher.on('unlink', handleEvent('unlink'));

     watcher.on('error', (error) => {
       console.error('Watcher error:', error.message);
     });

     return watcher;
   }
   ```

   Key points:
   - `awaitWriteFinish.stabilityThreshold` is 2000ms for Windows compatibility
   - `ignoreInitial: true` prevents add events for existing files on startup
   - `relative(watchPath, filePath)` produces paths like `.planning/STATE.md`
   - Only watches `**/*.md` inside `.planning/`
   - Returns the watcher instance for lifecycle management

4. Create `tests/services/sse.service.test.js` with the following content:
   ```javascript
   import { describe, it, expect, vi, beforeEach } from 'vitest';
   import {
     addClient,
     removeClient,
     broadcast,
     getClientCount,
     clearClients
   } from '../../src/services/sse.service.js';

   describe('sse.service', () => {
     let mockRes;

     beforeEach(() => {
       clearClients();
       mockRes = { write: vi.fn() };
     });

     it('should add a client and report correct count', () => {
       addClient(mockRes);
       expect(getClientCount()).toBe(1);
     });

     it('should remove a client and report correct count', () => {
       addClient(mockRes);
       removeClient(mockRes);
       expect(getClientCount()).toBe(0);
     });

     it('should not error when removing a client that was never added', () => {
       removeClient(mockRes);
       expect(getClientCount()).toBe(0);
     });

     it('should broadcast event to all connected clients', () => {
       const mockRes1 = { write: vi.fn() };
       const mockRes2 = { write: vi.fn() };

       addClient(mockRes1);
       addClient(mockRes2);

       broadcast('file-change', { path: '.planning/STATE.md', type: 'change' });

       expect(mockRes1.write).toHaveBeenCalledOnce();
       expect(mockRes2.write).toHaveBeenCalledOnce();

       const written1 = mockRes1.write.mock.calls[0][0];
       expect(written1).toContain('event: file-change');
       expect(written1).toContain('"path":".planning/STATE.md"');
       expect(written1).toContain('"type":"change"');
       expect(written1).toMatch(/id: \d+/);
       expect(written1).toMatch(/\n\n$/);
     });

     it('should not broadcast to clients after they are removed', () => {
       addClient(mockRes);
       removeClient(mockRes);

       broadcast('file-change', { path: 'test.md', type: 'change' });

       expect(mockRes.write).not.toHaveBeenCalled();
     });

     it('should remove client automatically if write throws', () => {
       const failingRes = {
         write: vi.fn(() => { throw new Error('connection reset'); })
       };

       addClient(failingRes);
       expect(getClientCount()).toBe(1);

       broadcast('file-change', { path: 'test.md', type: 'change' });

       expect(getClientCount()).toBe(0);
     });

     it('should clear all clients', () => {
       addClient({ write: vi.fn() });
       addClient({ write: vi.fn() });
       addClient({ write: vi.fn() });

       expect(getClientCount()).toBe(3);

       clearClients();
       expect(getClientCount()).toBe(0);
     });
   });
   ```

5. Create `tests/services/watcher.service.test.js` with the following content:
   ```javascript
   import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

   // Mock chokidar before importing watcher service
   const mockWatcher = {
     on: vi.fn(function (event, handler) {
       this._handlers = this._handlers || {};
       this._handlers[event] = handler;
       return this;
     }),
     close: vi.fn().mockResolvedValue(undefined),
     _emit(event, ...args) {
       if (this._handlers && this._handlers[event]) {
         this._handlers[event](...args);
       }
     }
   };

   vi.mock('chokidar', () => ({
     default: {
       watch: vi.fn(() => mockWatcher)
     }
   }));

   // Import after mock
   const { createWatcher } = await import('../../src/services/watcher.service.js');
   const chokidar = (await import('chokidar')).default;

   describe('watcher.service', () => {
     let onChange;

     beforeEach(() => {
       vi.clearAllMocks();
       mockWatcher._handlers = {};
       onChange = vi.fn();
     });

     it('should call chokidar.watch with correct path and options', () => {
       createWatcher('/project', onChange);

       expect(chokidar.watch).toHaveBeenCalledOnce();

       const [watchPath, options] = chokidar.watch.mock.calls[0];
       // Path should include .planning/**/*.md (platform-specific separator is OK)
       expect(watchPath).toContain('.planning');
       expect(watchPath).toContain('*.md');
       expect(options.ignoreInitial).toBe(true);
       expect(options.persistent).toBe(true);
       expect(options.awaitWriteFinish).toBeDefined();
       expect(options.awaitWriteFinish.stabilityThreshold).toBe(2000);
     });

     it('should register handlers for add, change, unlink, and error events', () => {
       createWatcher('/project', onChange);

       expect(mockWatcher.on).toHaveBeenCalledWith('add', expect.any(Function));
       expect(mockWatcher.on).toHaveBeenCalledWith('change', expect.any(Function));
       expect(mockWatcher.on).toHaveBeenCalledWith('unlink', expect.any(Function));
       expect(mockWatcher.on).toHaveBeenCalledWith('error', expect.any(Function));
     });

     it('should call onChange with normalized event on file change', () => {
       createWatcher('/project', onChange);

       // Simulate a change event with an absolute path
       const absPath = '/project/.planning/STATE.md';
       mockWatcher._emit('change', absPath);

       expect(onChange).toHaveBeenCalledOnce();
       const event = onChange.mock.calls[0][0];
       expect(event.type).toBe('change');
       expect(event.path).toContain('.planning');
       expect(event.path).toContain('STATE.md');
       expect(typeof event.timestamp).toBe('number');
     });

     it('should call onChange with type add on file add', () => {
       createWatcher('/project', onChange);

       mockWatcher._emit('add', '/project/.planning/new-file.md');

       expect(onChange).toHaveBeenCalledOnce();
       expect(onChange.mock.calls[0][0].type).toBe('add');
     });

     it('should call onChange with type unlink on file removal', () => {
       createWatcher('/project', onChange);

       mockWatcher._emit('unlink', '/project/.planning/removed-file.md');

       expect(onChange).toHaveBeenCalledOnce();
       expect(onChange.mock.calls[0][0].type).toBe('unlink');
     });
   });
   ```

   Key points:
   - chokidar is fully mocked (no real filesystem interaction)
   - mockWatcher has a `_emit` helper to simulate chokidar events
   - Tests verify correct options passed to chokidar.watch()
   - Tests verify normalized event objects are passed to onChange
   - Uses top-level await for importing after vi.mock() (ESM pattern established in Phase 02)
  </action>
  <verify>
    npx --prefix D:/Repos/towline-test-project vitest run --reporter=verbose tests/services/sse.service.test.js tests/services/watcher.service.test.js
  </verify>
  <done>
    SSE service manages client connections and broadcasts events with correct SSE format. Watcher service wraps chokidar with correct options and produces normalized events. All 12 unit tests pass.
  </done>
</task>

<task id="10-01-T2" type="auto">
  <name>Create SSE route, update app.js with route mount, update server.js for watcher lifecycle</name>
  <files>
    src/routes/events.routes.js
    src/app.js
    src/server.js
  </files>
  <action>
1. Create `src/routes/events.routes.js` with the following content:
   ```javascript
   import { Router } from 'express';
   import { addClient, removeClient } from '../services/sse.service.js';

   const router = Router();

   /**
    * GET /stream - Server-Sent Events endpoint.
    * Establishes a long-lived SSE connection. Events are pushed by the SSE service
    * when the file watcher detects changes. Heartbeat comments every 30s keep the
    * connection alive.
    */
   router.get('/stream', (req, res) => {
     // Set SSE headers
     res.writeHead(200, {
       'Content-Type': 'text/event-stream',
       'Cache-Control': 'no-cache',
       'Connection': 'keep-alive',
       'X-Accel-Buffering': 'no'
     });
     res.flushHeaders();

     // Send initial connection confirmation
     res.write(': connected\n\n');

     // Register this client for broadcasts
     addClient(res);

     // Heartbeat every 30 seconds to keep connection alive
     const heartbeat = setInterval(() => {
       res.write(': heartbeat\n\n');
     }, 30000);

     // Clean up on client disconnect
     req.on('close', () => {
       clearInterval(heartbeat);
       removeClient(res);
     });
   });

   export default router;
   ```

   Key points:
   - `res.writeHead()` + `res.flushHeaders()` sends headers immediately
   - `: connected\n\n` is an SSE comment (starts with `:`) confirming the stream is live
   - `: heartbeat\n\n` is also an SSE comment, ignored by EventSource but keeps connection alive
   - `X-Accel-Buffering: no` disables Nginx buffering if ever proxied
   - `req.on('close')` fires when browser disconnects or navigates away
   - The heartbeat interval is cleared on disconnect to prevent memory leaks
   - The route handler is NOT async (SSE is long-lived, never resolves)

2. Open `src/app.js` and add the events router.

   Add this import after the existing router imports (after the `import pagesRouter` or
   `import indexRouter` line):
   ```javascript
   import eventsRouter from './routes/events.routes.js';
   ```

   Add this route mount BEFORE the error handler line (`app.use(errorHandler)`):
   ```javascript
   app.use('/api/events', eventsRouter);
   ```

   The final routes section in createApp should look like:
   ```javascript
   // Routes
   app.use('/', indexRouter);
   app.use('/', pagesRouter);
   app.use('/api/events', eventsRouter);

   // Error handler MUST be registered last
   app.use(errorHandler);
   ```

3. Open `src/server.js` and update it to create the watcher and wire it to SSE broadcasts.

   Replace the entire contents of `src/server.js` with:
   ```javascript
   import { createApp } from './app.js';
   import { createWatcher } from './services/watcher.service.js';
   import { broadcast } from './services/sse.service.js';

   export function startServer(config) {
     const app = createApp(config);
     const { port, projectDir } = config;

     // Start file watcher for live updates
     const watcher = createWatcher(projectDir, (event) => {
       broadcast('file-change', event);
     });

     const server = app.listen(port, '127.0.0.1', () => {
       console.log(`Towline Dashboard running at http://127.0.0.1:${port}`);
       console.log(`Project directory: ${projectDir}`);
       console.log('File watcher active on .planning/**/*.md');
     });

     const shutdown = async (signal) => {
       console.log(`${signal} received. Shutting down Towline Dashboard...`);

       // Close watcher first (stops generating events)
       try {
         await watcher.close();
         console.log('File watcher closed.');
       } catch (err) {
         console.error('Error closing watcher:', err.message);
       }

       // Then close the HTTP server
       server.close(() => {
         console.log('Server closed.');
         process.exit(0);
       });
     };

     process.on('SIGTERM', () => shutdown('SIGTERM'));
     process.on('SIGINT', () => shutdown('SIGINT'));

     return server;
   }
   ```

   Key changes from Phase 01 server.js:
   - Imports `createWatcher` and `broadcast`
   - Creates watcher with `projectDir` and wires onChange to `broadcast('file-change', event)`
   - Shutdown handler is now `async` to `await watcher.close()` before `server.close()`
   - Shutdown handler receives signal name for better logging
   - Watcher is closed FIRST (stops generating new events), then server closes
   - Watcher close error is caught and logged but does not prevent server shutdown
   - Added log line confirming watcher is active
  </action>
  <verify>
    node -e "const fs = require('fs'); const a = fs.readFileSync('D:/Repos/towline-test-project/src/app.js','utf-8'); const s = fs.readFileSync('D:/Repos/towline-test-project/src/server.js','utf-8'); const e = fs.readFileSync('D:/Repos/towline-test-project/src/routes/events.routes.js','utf-8'); if (!a.includes('eventsRouter')) throw new Error('app.js missing eventsRouter'); if (!a.includes('/api/events')) throw new Error('app.js missing /api/events mount'); if (!s.includes('createWatcher')) throw new Error('server.js missing createWatcher'); if (!s.includes('watcher.close')) throw new Error('server.js missing watcher.close'); if (!s.includes('broadcast')) throw new Error('server.js missing broadcast'); if (!e.includes('text/event-stream')) throw new Error('events.routes.js missing SSE content type'); if (!e.includes('heartbeat')) throw new Error('events.routes.js missing heartbeat'); if (!e.includes('addClient')) throw new Error('events.routes.js missing addClient'); if (!e.includes('removeClient')) throw new Error('events.routes.js missing removeClient'); console.log('PASS: all 3 files have expected SSE infrastructure');" && npx --prefix D:/Repos/towline-test-project vitest run --reporter=verbose
  </verify>
  <done>
    SSE route serves GET /api/events/stream with correct headers and heartbeat. App.js mounts the events router at /api/events. Server.js creates a file watcher on startup, wires file changes to SSE broadcasts, and closes the watcher before the server on shutdown. All existing tests plus new tests pass.
  </done>
</task>
