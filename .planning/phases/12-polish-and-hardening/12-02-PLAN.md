---
phase: "12-polish-and-hardening"
plan: "12-02"
type: "feature"
wave: 2
depends_on: ["12-01"]
files_modified:
  - "src/repositories/planning.repository.js"
  - "src/app.js"
  - "package.json"
  - "tests/repositories/planning.repository.test.js"
  - "tests/security/path-traversal.test.js"
  - "tests/security/cross-platform.test.js"
autonomous: true
discovery: 0
must_haves:
  truths:
    - "Path traversal attempts are rejected with 403 status before any file I/O occurs"
    - "readMarkdownFile wraps gray-matter errors into user-friendly messages with status 400"
    - "Helmet security headers are present on all responses (X-Content-Type-Options, X-Frame-Options, etc.)"
    - "X-Powered-By header is absent from all responses"
    - "Cross-platform path joining works correctly on both Windows and POSIX"
    - "Server binds to 127.0.0.1 only (validated by test)"
  artifacts:
    - "src/repositories/planning.repository.js (with validatePath export and gray-matter error handling)"
    - "src/app.js (with helmet middleware)"
    - "tests/repositories/planning.repository.test.js (extended with gray-matter error tests)"
    - "tests/security/path-traversal.test.js"
    - "tests/security/cross-platform.test.js"
  key_links:
    - "validatePath is called by any service that resolves user-provided paths against a base directory"
    - "helmet() middleware registered before all routes in app.js"
    - "CSP configured to allow CDN scripts for HTMX and Pico.css"
---

# Plan 12-02: Security Hardening and Cross-Platform Validation

## Goal
Implement path traversal protection in the repository layer, add gray-matter YAML error
handling, install Helmet for security headers, and create cross-platform path tests to
validate Windows and POSIX path handling.

## Tasks

<task id="12-02-T1" type="auto" tdd="false">
  <name>Add validatePath, gray-matter error handling, and Helmet security headers</name>
  <files>
    src/repositories/planning.repository.js
    src/app.js
    package.json
  </files>
  <action>
    1. Install helmet:
       ```bash
       cd D:\Repos\towline-test-project && npm install helmet
       ```

    2. Update `src/repositories/planning.repository.js`:

       a. Add imports at top -- change the existing path import line from:
          ```javascript
          import { join } from 'node:path';
          ```
          to:
          ```javascript
          import { join, resolve, relative, normalize } from 'node:path';
          ```

       b. Add the `validatePath` function AFTER `stripBOM` and BEFORE `readMarkdownFile`.
          Export it (it will be used by services and tested directly):
          ```javascript
          /**
           * Validate that a resolved path stays within the base directory.
           * Prevents path traversal attacks (e.g., ../../etc/passwd).
           *
           * @param {string} basePath - Absolute base directory path
           * @param {string} userPath - User-provided path (may be relative)
           * @returns {string} Validated absolute path
           * @throws {Error} With status 403 if path escapes base directory
           */
          export function validatePath(basePath, userPath) {
            const resolvedBase = normalize(resolve(basePath));
            const resolvedUser = normalize(resolve(basePath, userPath));

            // Compute the relative path from base to target
            const rel = relative(resolvedBase, resolvedUser);

            // If relative path starts with '..' it escaped the base directory.
            // If rel resolves to an absolute path, it was an absolute path injection.
            if (rel.startsWith('..') || resolve(rel) === rel) {
              const err = new Error('Path traversal attempt detected');
              err.status = 403;
              err.code = 'PATH_TRAVERSAL';
              throw err;
            }

            return resolvedUser;
          }
          ```

       c. Wrap the gray-matter parse call in `readMarkdownFile` with a try-catch.
          Replace the body of `readMarkdownFile` (the part after `stripBOM`) from:
          ```javascript
          const { data, content } = matter(cleanContent, {
            engines: {
              javascript: false
            }
          });

          const html = marked.parse(content);

          return {
            frontmatter: data,
            html,
            rawContent: content
          };
          ```
          with:
          ```javascript
          let data, content;
          try {
            ({ data, content } = matter(cleanContent, {
              engines: {
                javascript: false
              }
            }));
          } catch (error) {
            // gray-matter throws YAMLException for malformed frontmatter.
            // Wrap it in a user-friendly error with status 400.
            if (error.name === 'YAMLException' || (error.constructor && error.constructor.name === 'YAMLException')) {
              const wrapped = new Error(`Invalid YAML frontmatter in ${filePath}: ${error.message}`);
              wrapped.status = 400;
              wrapped.cause = error;
              throw wrapped;
            }
            throw error;
          }

          const html = marked.parse(content);

          return {
            frontmatter: data,
            html,
            rawContent: content
          };
          ```

    3. Update `src/app.js`:

       a. Add helmet import at top (after the existing express import):
          ```javascript
          import helmet from 'helmet';
          ```

       b. Add helmet middleware and disable x-powered-by AFTER `const app = express();`
          and BEFORE the view engine setup. Add these lines:
          ```javascript
          // Security headers via Helmet
          // CSP allows CDN scripts (HTMX, Pico.css, htmx-ext-sse) and inline styles
          app.use(helmet({
            contentSecurityPolicy: {
              directives: {
                defaultSrc: ["'self'"],
                scriptSrc: ["'self'", "https://cdn.jsdelivr.net"],
                styleSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
                imgSrc: ["'self'", "data:"],
                connectSrc: ["'self'"],
                fontSrc: ["'self'", "https://cdn.jsdelivr.net"]
              }
            }
          }));
          app.disable('x-powered-by');
          ```

          NOTE: `'unsafe-inline'` for styleSrc is needed because Pico.css uses inline
          styles in some cases. scriptSrc does NOT need `'unsafe-inline'` because HTMX
          and Alpine.js are loaded from CDN, not inline. The connectSrc `'self'` allows
          SSE connections to the same origin.
  </action>
  <verify>
    npx --prefix D:/Repos/towline-test-project vitest run tests/security/path-traversal.test.js tests/repositories/planning.repository.test.js --reporter=verbose
  </verify>
  <done>
    The repository layer exports validatePath for path traversal protection,
    readMarkdownFile wraps gray-matter YAMLException into status 400 errors,
    and all HTTP responses include Helmet security headers with CSP configured
    for CDN scripts.
  </done>
</task>

<task id="12-02-T2" type="auto" tdd="false">
  <name>Write path traversal, gray-matter error, cross-platform, and security header tests</name>
  <files>
    tests/repositories/planning.repository.test.js
    tests/security/path-traversal.test.js
    tests/security/cross-platform.test.js
  </files>
  <action>
    1. Extend `tests/repositories/planning.repository.test.js`:

       The existing file already imports from planning.repository.js via dynamic import
       after vi.mock. Add `validatePath` to the destructured imports:
       ```javascript
       const {
         readMarkdownFile,
         readMarkdownFiles,
         readMarkdownFilesSettled,
         listPlanningFiles,
         validatePath
       } = await import('../../src/repositories/planning.repository.js');
       ```

       Add a new describe block after the existing `listPlanningFiles` describe block:

       ```javascript
       describe('readMarkdownFile error handling', () => {
         it('should throw status 400 for malformed YAML frontmatter', async () => {
           vol.fromJSON({
             '/project/bad.md': '---\ntitle: Test\nstatus [invalid yaml\n---\nContent'
           });

           try {
             await readMarkdownFile('/project/bad.md');
             expect.fail('Should have thrown');
           } catch (error) {
             expect(error.message).toContain('Invalid YAML frontmatter');
             expect(error.message).toContain('/project/bad.md');
             expect(error.status).toBe(400);
             expect(error.cause).toBeDefined();
           }
         });

         it('should throw status 400 for unclosed frontmatter with bad YAML', async () => {
           vol.fromJSON({
             '/project/unclosed.md': '---\ntitle: {{broken\n  invalid: [[\n---\nContent'
           });

           try {
             await readMarkdownFile('/project/unclosed.md');
             expect.fail('Should have thrown');
           } catch (error) {
             expect(error.status).toBe(400);
           }
         });

         it('should handle empty file without error', async () => {
           vol.fromJSON({
             '/project/empty.md': ''
           });

           const result = await readMarkdownFile('/project/empty.md');
           expect(result.frontmatter).toEqual({});
           expect(result.html).toBe('');
         });

         it('should handle file with only frontmatter (no body)', async () => {
           vol.fromJSON({
             '/project/fm-only.md': '---\ntitle: Only Frontmatter\n---\n'
           });

           const result = await readMarkdownFile('/project/fm-only.md');
           expect(result.frontmatter.title).toBe('Only Frontmatter');
           expect(result.rawContent).toBe('\n');
         });

         it('should propagate non-YAML errors unchanged', async () => {
           // ENOENT should pass through without being wrapped in status 400
           try {
             await readMarkdownFile('/project/nonexistent.md');
             expect.fail('Should have thrown');
           } catch (error) {
             expect(error.code).toBe('ENOENT');
             expect(error.status).toBeUndefined();
           }
         });
       });
       ```

    2. Create `tests/security/path-traversal.test.js`:

       ```javascript
       import { describe, it, expect } from 'vitest';
       import { validatePath } from '../../src/repositories/planning.repository.js';

       describe('Path Traversal Protection', () => {
         // Use a platform-appropriate base path for testing.
         // validatePath uses path.resolve internally which handles platform differences.
         const baseDir = process.platform === 'win32'
           ? 'C:\\project\\.planning'
           : '/home/user/project/.planning';

         describe('valid paths', () => {
           it('should allow a simple relative filename', () => {
             const result = validatePath(baseDir, 'ROADMAP.md');
             expect(result).toContain('ROADMAP.md');
           });

           it('should allow nested relative paths', () => {
             const result = validatePath(baseDir, 'phases/01-setup/01-01-PLAN.md');
             expect(result).toContain('phases');
             expect(result).toContain('01-01-PLAN.md');
           });

           it('should allow paths with the base directory itself (empty relative)', () => {
             const result = validatePath(baseDir, '.');
             // Should resolve to the base directory itself
             expect(result).toBeTruthy();
           });
         });

         describe('rejected paths', () => {
           it('should reject parent directory traversal (../)', () => {
             expect(() => validatePath(baseDir, '../../../etc/passwd'))
               .toThrow('Path traversal attempt detected');
           });

           it('should reject parent traversal with status 403', () => {
             try {
               validatePath(baseDir, '../secret.txt');
             } catch (error) {
               expect(error.status).toBe(403);
               expect(error.code).toBe('PATH_TRAVERSAL');
             }
           });

           it('should reject single parent traversal (..)', () => {
             expect(() => validatePath(baseDir, '..'))
               .toThrow('Path traversal attempt detected');
           });

           it('should reject encoded parent traversal via nested ../', () => {
             expect(() => validatePath(baseDir, 'phases/../../secrets'))
               .toThrow('Path traversal attempt detected');
           });

           it('should reject absolute path injection on POSIX', () => {
             // This test uses an absolute POSIX path regardless of platform.
             // On Windows, path.resolve('C:\\base', '/etc/passwd') resolves to
             // the root of the current drive, which is still outside the base.
             expect(() => validatePath(baseDir, '/etc/passwd'))
               .toThrow('Path traversal attempt detected');
           });
         });

         describe('edge cases', () => {
           it('should handle paths with redundant separators', () => {
             // path.normalize handles these
             const result = validatePath(baseDir, 'phases//01-setup///PLAN.md');
             expect(result).toContain('PLAN.md');
           });

           it('should handle dot segments that resolve within base', () => {
             // './phases/../phases/01/PLAN.md' should resolve within base
             const result = validatePath(baseDir, './phases/../phases/01/PLAN.md');
             expect(result).toContain('PLAN.md');
           });
         });
       });
       ```

    3. Create `tests/security/cross-platform.test.js`:

       ```javascript
       import { describe, it, expect } from 'vitest';
       import { win32, posix, join, resolve, normalize, sep } from 'node:path';

       describe('Cross-Platform Path Handling', () => {
         describe('path.win32 (Windows behavior on any OS)', () => {
           it('should join Windows paths with backslashes', () => {
             const result = win32.join('C:\\', 'project', '.planning', 'ROADMAP.md');
             expect(result).toBe('C:\\project\\.planning\\ROADMAP.md');
           });

           it('should normalize mixed separators to backslashes', () => {
             const result = win32.normalize('C:/project/.planning\\ROADMAP.md');
             expect(result).toBe('C:\\project\\.planning\\ROADMAP.md');
           });

           it('should resolve relative paths against a Windows base', () => {
             const result = win32.resolve('C:\\project\\.planning', 'phases', '01-setup');
             expect(result).toBe('C:\\project\\.planning\\phases\\01-setup');
           });

           it('should detect parent traversal in relative paths', () => {
             const rel = win32.relative('C:\\project\\.planning', 'C:\\project\\secrets');
             expect(rel.startsWith('..')).toBe(true);
           });
         });

         describe('path.posix (POSIX behavior on any OS)', () => {
           it('should join POSIX paths with forward slashes', () => {
             const result = posix.join('/', 'home', 'user', 'project', '.planning', 'ROADMAP.md');
             expect(result).toBe('/home/user/project/.planning/ROADMAP.md');
           });

           it('should normalize redundant separators', () => {
             const result = posix.normalize('/home//user///project/.planning/ROADMAP.md');
             expect(result).toBe('/home/user/project/.planning/ROADMAP.md');
           });

           it('should resolve relative paths against a POSIX base', () => {
             const result = posix.resolve('/home/user/project/.planning', 'phases', '01-setup');
             expect(result).toBe('/home/user/project/.planning/phases/01-setup');
           });

           it('should detect parent traversal in relative paths', () => {
             const rel = posix.relative('/project/.planning', '/project/secrets');
             expect(rel.startsWith('..')).toBe(true);
           });
         });

         describe('current platform path operations', () => {
           it('should use path.join for directory construction (never manual concatenation)', () => {
             const projectDir = sep === '\\' ? 'C:\\project' : '/home/user/project';
             const result = join(projectDir, '.planning', 'phases', '01-setup', '01-01-PLAN.md');
             // Result should contain the correct separator for the platform
             expect(result).toContain('.planning');
             expect(result).toContain('01-01-PLAN.md');
           });

           it('should use path.resolve for absolute path resolution', () => {
             const result = resolve('.', 'src', 'app.js');
             // Result should be an absolute path
             expect(result).toMatch(sep === '\\' ? /^[A-Z]:\\/ : /^\//);
           });

           it('should use path.normalize to clean up paths', () => {
             const messy = join('project', '.planning', '..', '.planning', 'ROADMAP.md');
             const clean = normalize(messy);
             expect(clean).toContain('ROADMAP.md');
             // Should NOT contain '..' since it was resolved
             expect(clean).not.toContain('..');
           });
         });

         describe('server binding validation', () => {
           it('should confirm server.js binds to 127.0.0.1', async () => {
             // Read server.js source and verify the listen call binds to localhost
             const { readFile } = await import('node:fs/promises');
             const serverSource = await readFile(
               join(resolve('.'), 'src', 'server.js'),
               'utf-8'
             );
             // The listen call must specify '127.0.0.1' as the hostname
             expect(serverSource).toContain("'127.0.0.1'");
             expect(serverSource).toMatch(/app\.listen\(\s*port\s*,\s*'127\.0\.0\.1'/);
           });
         });

         describe('Helmet security headers', () => {
           it('should set security headers and remove X-Powered-By', async () => {
             // Import createApp and create an Express app instance to verify Helmet is wired
             const { createApp } = await import('../../src/app.js');
             const app = createApp({ projectDir: resolve('.') });

             // Use a simple supertest-free approach: create a test request via app.handle
             const http = await import('node:http');
             const server = http.createServer(app);

             // Make a request and inspect response headers
             await new Promise((resolvePromise, reject) => {
               server.listen(0, '127.0.0.1', () => {
                 const { port } = server.address();
                 http.get(`http://127.0.0.1:${port}/`, (res) => {
                   try {
                     // Helmet should set X-Content-Type-Options
                     expect(res.headers['x-content-type-options']).toBe('nosniff');
                     // Helmet should set X-Frame-Options (or Content-Security-Policy frame-ancestors)
                     // At minimum, one of these should exist
                     const hasFrameProtection = res.headers['x-frame-options'] ||
                       (res.headers['content-security-policy'] && res.headers['content-security-policy'].includes('frame-ancestors'));
                     expect(hasFrameProtection).toBeTruthy();
                     // X-Powered-By MUST be absent
                     expect(res.headers['x-powered-by']).toBeUndefined();
                     // Content-Security-Policy should include our CDN allowlist
                     expect(res.headers['content-security-policy']).toContain('cdn.jsdelivr.net');
                     resolvePromise();
                   } catch (err) {
                     reject(err);
                   } finally {
                     server.close();
                   }
                 }).on('error', (err) => {
                   server.close();
                   reject(err);
                 });
               });
             });
           });
         });
       });
       ```

       NOTE: The Helmet test creates a real HTTP server on a random port (port 0),
       makes one request, inspects the response headers, and tears down the server.
       This validates that Helmet is actually wired into the Express app and producing
       the expected security headers at runtime. The X-Powered-By check confirms
       `app.disable('x-powered-by')` is effective.
  </action>
  <verify>
    npx --prefix D:/Repos/towline-test-project vitest run tests/repositories/planning.repository.test.js --reporter=verbose
    npx --prefix D:/Repos/towline-test-project vitest run tests/security/path-traversal.test.js --reporter=verbose
    npx --prefix D:/Repos/towline-test-project vitest run tests/security/cross-platform.test.js --reporter=verbose
  </verify>
  <done>
    Path traversal protection rejects escape attempts with 403 status, gray-matter
    errors produce user-friendly 400 messages, cross-platform path tests pass for
    both Windows and POSIX, Helmet security headers are present on responses,
    X-Powered-By is absent, and server binding to 127.0.0.1 is validated.
  </done>
</task>

<task id="12-02-T3" type="auto" tdd="false">
  <name>Run full test suite to verify no regressions</name>
  <files>
  </files>
  <action>
    1. Run the complete test suite to verify that all existing 114 tests still pass
       alongside the new security and error handling tests:
       ```bash
       cd D:\Repos\towline-test-project && npx vitest run
       ```

    2. If any tests fail:
       - Check whether the gray-matter error handling change broke the existing
         "should throw on malformed YAML frontmatter" test in planning.repository.test.js.
         The existing test at line 84-92 uses `await expect(...).rejects.toThrow()`
         without checking the error message. The new behavior wraps YAMLException into
         a custom error with "Invalid YAML frontmatter" message -- the test should still
         pass because it just checks `.toThrow()` without a specific message.
       - If the old test now fails, it means gray-matter does NOT throw YAMLException
         for that specific input. Investigate the error type and adjust the catch
         condition in readMarkdownFile accordingly.

    3. Verify the test count increased from 114 to approximately 135+ tests (the exact
       number depends on the new test files).
  </action>
  <verify>
    npx --prefix D:/Repos/towline-test-project vitest run --reporter=verbose
  </verify>
  <done>
    All tests pass with zero regressions. The full test suite includes the original
    114 tests plus the new error handling, path traversal, and cross-platform tests.
  </done>
</task>
